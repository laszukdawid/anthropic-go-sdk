// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for APIErrorType.
const (
	APIErrorTypeApiError APIErrorType = "api_error"
)

// Defines values for AuthenticationErrorType.
const (
	AuthenticationErrorTypeAuthenticationError AuthenticationErrorType = "authentication_error"
)

// Defines values for Base64ImageSourceMediaType.
const (
	Base64ImageSourceMediaTypeImagegif  Base64ImageSourceMediaType = "image/gif"
	Base64ImageSourceMediaTypeImagejpeg Base64ImageSourceMediaType = "image/jpeg"
	Base64ImageSourceMediaTypeImagepng  Base64ImageSourceMediaType = "image/png"
	Base64ImageSourceMediaTypeImagewebp Base64ImageSourceMediaType = "image/webp"
)

// Defines values for Base64ImageSourceType.
const (
	Base64ImageSourceTypeBase64 Base64ImageSourceType = "base64"
)

// Defines values for BetaAPIErrorType.
const (
	BetaAPIErrorTypeApiError BetaAPIErrorType = "api_error"
)

// Defines values for BetaAuthenticationErrorType.
const (
	BetaAuthenticationErrorTypeAuthenticationError BetaAuthenticationErrorType = "authentication_error"
)

// Defines values for BetaBase64ImageSourceMediaType.
const (
	BetaBase64ImageSourceMediaTypeImagegif  BetaBase64ImageSourceMediaType = "image/gif"
	BetaBase64ImageSourceMediaTypeImagejpeg BetaBase64ImageSourceMediaType = "image/jpeg"
	BetaBase64ImageSourceMediaTypeImagepng  BetaBase64ImageSourceMediaType = "image/png"
	BetaBase64ImageSourceMediaTypeImagewebp BetaBase64ImageSourceMediaType = "image/webp"
)

// Defines values for BetaBase64ImageSourceType.
const (
	BetaBase64ImageSourceTypeBase64 BetaBase64ImageSourceType = "base64"
)

// Defines values for BetaBase64PDFSourceMediaType.
const (
	Applicationpdf BetaBase64PDFSourceMediaType = "application/pdf"
)

// Defines values for BetaBase64PDFSourceType.
const (
	Base64 BetaBase64PDFSourceType = "base64"
)

// Defines values for BetaBashTool20241022Name.
const (
	Bash BetaBashTool20241022Name = "bash"
)

// Defines values for BetaBashTool20241022Type.
const (
	Bash20241022 BetaBashTool20241022Type = "bash_20241022"
)

// Defines values for BetaCacheControlEphemeralType.
const (
	BetaCacheControlEphemeralTypeEphemeral BetaCacheControlEphemeralType = "ephemeral"
)

// Defines values for BetaComputerUseTool20241022Name.
const (
	Computer BetaComputerUseTool20241022Name = "computer"
)

// Defines values for BetaComputerUseTool20241022Type.
const (
	Computer20241022 BetaComputerUseTool20241022Type = "computer_20241022"
)

// Defines values for BetaErrorResponseType.
const (
	BetaErrorResponseTypeError BetaErrorResponseType = "error"
)

// Defines values for BetaInputMessageRole.
const (
	BetaInputMessageRoleAssistant BetaInputMessageRole = "assistant"
	BetaInputMessageRoleUser      BetaInputMessageRole = "user"
)

// Defines values for BetaInputSchemaType.
const (
	BetaInputSchemaTypeObject BetaInputSchemaType = "object"
)

// Defines values for BetaInvalidRequestErrorType.
const (
	BetaInvalidRequestErrorTypeInvalidRequestError BetaInvalidRequestErrorType = "invalid_request_error"
)

// Defines values for BetaMessageBatchProcessingStatus.
const (
	Canceling  BetaMessageBatchProcessingStatus = "canceling"
	Ended      BetaMessageBatchProcessingStatus = "ended"
	InProgress BetaMessageBatchProcessingStatus = "in_progress"
)

// Defines values for BetaMessageBatchType.
const (
	MessageBatch BetaMessageBatchType = "message_batch"
)

// Defines values for BetaNotFoundErrorType.
const (
	BetaNotFoundErrorTypeNotFoundError BetaNotFoundErrorType = "not_found_error"
)

// Defines values for BetaOverloadedErrorType.
const (
	BetaOverloadedErrorTypeOverloadedError BetaOverloadedErrorType = "overloaded_error"
)

// Defines values for BetaPermissionErrorType.
const (
	BetaPermissionErrorTypePermissionError BetaPermissionErrorType = "permission_error"
)

// Defines values for BetaRateLimitErrorType.
const (
	BetaRateLimitErrorTypeRateLimitError BetaRateLimitErrorType = "rate_limit_error"
)

// Defines values for BetaRequestImageBlockType.
const (
	BetaRequestImageBlockTypeImage BetaRequestImageBlockType = "image"
)

// Defines values for BetaRequestPDFBlockType.
const (
	Document BetaRequestPDFBlockType = "document"
)

// Defines values for BetaRequestTextBlockType.
const (
	BetaRequestTextBlockTypeText BetaRequestTextBlockType = "text"
)

// Defines values for BetaRequestToolResultBlockType.
const (
	BetaRequestToolResultBlockTypeToolResult BetaRequestToolResultBlockType = "tool_result"
)

// Defines values for BetaRequestToolUseBlockType.
const (
	BetaRequestToolUseBlockTypeToolUse BetaRequestToolUseBlockType = "tool_use"
)

// Defines values for BetaTextEditor20241022Name.
const (
	StrReplaceEditor BetaTextEditor20241022Name = "str_replace_editor"
)

// Defines values for BetaTextEditor20241022Type.
const (
	TextEditor20241022 BetaTextEditor20241022Type = "text_editor_20241022"
)

// Defines values for BetaToolType0.
const (
	Custom BetaToolType0 = "custom"
)

// Defines values for BetaToolChoiceAnyType.
const (
	BetaToolChoiceAnyTypeAny BetaToolChoiceAnyType = "any"
)

// Defines values for BetaToolChoiceAutoType.
const (
	BetaToolChoiceAutoTypeAuto BetaToolChoiceAutoType = "auto"
)

// Defines values for BetaToolChoiceToolType.
const (
	BetaToolChoiceToolTypeTool BetaToolChoiceToolType = "tool"
)

// Defines values for CacheControlEphemeralType.
const (
	CacheControlEphemeralTypeEphemeral CacheControlEphemeralType = "ephemeral"
)

// Defines values for CompletionResponseType.
const (
	Completion CompletionResponseType = "completion"
)

// Defines values for ErrorResponseType.
const (
	ErrorResponseTypeError ErrorResponseType = "error"
)

// Defines values for InputMessageRole.
const (
	InputMessageRoleAssistant InputMessageRole = "assistant"
	InputMessageRoleUser      InputMessageRole = "user"
)

// Defines values for InputSchemaType.
const (
	InputSchemaTypeObject InputSchemaType = "object"
)

// Defines values for InvalidRequestErrorType.
const (
	InvalidRequestErrorTypeInvalidRequestError InvalidRequestErrorType = "invalid_request_error"
)

// Defines values for MessageRole.
const (
	MessageRoleAssistant MessageRole = "assistant"
)

// Defines values for MessageStopReason0.
const (
	MessageStopReason0EndTurn      MessageStopReason0 = "end_turn"
	MessageStopReason0MaxTokens    MessageStopReason0 = "max_tokens"
	MessageStopReason0StopSequence MessageStopReason0 = "stop_sequence"
	MessageStopReason0ToolUse      MessageStopReason0 = "tool_use"
)

// Defines values for MessageType.
const (
	MessageTypeMessage MessageType = "message"
)

// Defines values for Model1.
const (
	Claude20               Model1 = "claude-2.0"
	Claude21               Model1 = "claude-2.1"
	Claude35Sonnet20240620 Model1 = "claude-3-5-sonnet-20240620"
	Claude35Sonnet20241022 Model1 = "claude-3-5-sonnet-20241022"
	Claude35SonnetLatest   Model1 = "claude-3-5-sonnet-latest"
	Claude3Haiku20240307   Model1 = "claude-3-haiku-20240307"
	Claude3Opus20240229    Model1 = "claude-3-opus-20240229"
	Claude3OpusLatest      Model1 = "claude-3-opus-latest"
	Claude3Sonnet20240229  Model1 = "claude-3-sonnet-20240229"
	ClaudeInstant12        Model1 = "claude-instant-1.2"
)

// Defines values for NotFoundErrorType.
const (
	NotFoundErrorTypeNotFoundError NotFoundErrorType = "not_found_error"
)

// Defines values for OverloadedErrorType.
const (
	OverloadedErrorTypeOverloadedError OverloadedErrorType = "overloaded_error"
)

// Defines values for PermissionErrorType.
const (
	PermissionErrorTypePermissionError PermissionErrorType = "permission_error"
)

// Defines values for PromptCachingBetaInputMessageRole.
const (
	PromptCachingBetaInputMessageRoleAssistant PromptCachingBetaInputMessageRole = "assistant"
	PromptCachingBetaInputMessageRoleUser      PromptCachingBetaInputMessageRole = "user"
)

// Defines values for PromptCachingBetaMessageRole.
const (
	Assistant PromptCachingBetaMessageRole = "assistant"
)

// Defines values for PromptCachingBetaMessageStopReason0.
const (
	PromptCachingBetaMessageStopReason0EndTurn      PromptCachingBetaMessageStopReason0 = "end_turn"
	PromptCachingBetaMessageStopReason0MaxTokens    PromptCachingBetaMessageStopReason0 = "max_tokens"
	PromptCachingBetaMessageStopReason0StopSequence PromptCachingBetaMessageStopReason0 = "stop_sequence"
	PromptCachingBetaMessageStopReason0ToolUse      PromptCachingBetaMessageStopReason0 = "tool_use"
)

// Defines values for PromptCachingBetaMessageType.
const (
	PromptCachingBetaMessageTypeMessage PromptCachingBetaMessageType = "message"
)

// Defines values for PromptCachingBetaRequestImageBlockType.
const (
	PromptCachingBetaRequestImageBlockTypeImage PromptCachingBetaRequestImageBlockType = "image"
)

// Defines values for PromptCachingBetaRequestTextBlockType.
const (
	PromptCachingBetaRequestTextBlockTypeText PromptCachingBetaRequestTextBlockType = "text"
)

// Defines values for PromptCachingBetaRequestToolResultBlockType.
const (
	PromptCachingBetaRequestToolResultBlockTypeToolResult PromptCachingBetaRequestToolResultBlockType = "tool_result"
)

// Defines values for PromptCachingBetaRequestToolUseBlockType.
const (
	PromptCachingBetaRequestToolUseBlockTypeToolUse PromptCachingBetaRequestToolUseBlockType = "tool_use"
)

// Defines values for RateLimitErrorType.
const (
	RateLimitErrorTypeRateLimitError RateLimitErrorType = "rate_limit_error"
)

// Defines values for RequestImageBlockType.
const (
	Image RequestImageBlockType = "image"
)

// Defines values for RequestTextBlockType.
const (
	RequestTextBlockTypeText RequestTextBlockType = "text"
)

// Defines values for RequestToolResultBlockType.
const (
	ToolResult RequestToolResultBlockType = "tool_result"
)

// Defines values for RequestToolUseBlockType.
const (
	RequestToolUseBlockTypeToolUse RequestToolUseBlockType = "tool_use"
)

// Defines values for ResponseTextBlockType.
const (
	ResponseTextBlockTypeText ResponseTextBlockType = "text"
)

// Defines values for ResponseToolUseBlockType.
const (
	ResponseToolUseBlockTypeToolUse ResponseToolUseBlockType = "tool_use"
)

// Defines values for ToolChoiceAnyType.
const (
	ToolChoiceAnyTypeAny ToolChoiceAnyType = "any"
)

// Defines values for ToolChoiceAutoType.
const (
	ToolChoiceAutoTypeAuto ToolChoiceAutoType = "auto"
)

// Defines values for ToolChoiceToolType.
const (
	ToolChoiceToolTypeTool ToolChoiceToolType = "tool"
)

// APIError defines model for APIError.
type APIError struct {
	Message string       `json:"message"`
	Type    APIErrorType `json:"type"`
}

// APIErrorType defines model for APIError.Type.
type APIErrorType string

// AuthenticationError defines model for AuthenticationError.
type AuthenticationError struct {
	Message string                  `json:"message"`
	Type    AuthenticationErrorType `json:"type"`
}

// AuthenticationErrorType defines model for AuthenticationError.Type.
type AuthenticationErrorType string

// Base64ImageSource defines model for Base64ImageSource.
type Base64ImageSource struct {
	Data      []byte                     `json:"data"`
	MediaType Base64ImageSourceMediaType `json:"media_type"`
	Type      Base64ImageSourceType      `json:"type"`
}

// Base64ImageSourceMediaType defines model for Base64ImageSource.MediaType.
type Base64ImageSourceMediaType string

// Base64ImageSourceType defines model for Base64ImageSource.Type.
type Base64ImageSourceType string

// BetaAPIError defines model for BetaAPIError.
type BetaAPIError struct {
	Message string           `json:"message"`
	Type    BetaAPIErrorType `json:"type"`
}

// BetaAPIErrorType defines model for BetaAPIError.Type.
type BetaAPIErrorType string

// BetaAuthenticationError defines model for BetaAuthenticationError.
type BetaAuthenticationError struct {
	Message string                      `json:"message"`
	Type    BetaAuthenticationErrorType `json:"type"`
}

// BetaAuthenticationErrorType defines model for BetaAuthenticationError.Type.
type BetaAuthenticationErrorType string

// BetaBase64ImageSource defines model for BetaBase64ImageSource.
type BetaBase64ImageSource struct {
	Data      []byte                         `json:"data"`
	MediaType BetaBase64ImageSourceMediaType `json:"media_type"`
	Type      BetaBase64ImageSourceType      `json:"type"`
}

// BetaBase64ImageSourceMediaType defines model for BetaBase64ImageSource.MediaType.
type BetaBase64ImageSourceMediaType string

// BetaBase64ImageSourceType defines model for BetaBase64ImageSource.Type.
type BetaBase64ImageSourceType string

// BetaBase64PDFSource defines model for BetaBase64PDFSource.
type BetaBase64PDFSource struct {
	Data      []byte                       `json:"data"`
	MediaType BetaBase64PDFSourceMediaType `json:"media_type"`
	Type      BetaBase64PDFSourceType      `json:"type"`
}

// BetaBase64PDFSourceMediaType defines model for BetaBase64PDFSource.MediaType.
type BetaBase64PDFSourceMediaType string

// BetaBase64PDFSourceType defines model for BetaBase64PDFSource.Type.
type BetaBase64PDFSourceType string

// BetaBashTool20241022 defines model for BetaBashTool_20241022.
type BetaBashTool20241022 struct {
	CacheControl *BetaBashTool20241022_CacheControl `json:"cache_control"`

	// Name Name of the tool.
	//
	// This is how the tool will be called by the model and in tool_use blocks.
	Name BetaBashTool20241022Name `json:"name"`
	Type BetaBashTool20241022Type `json:"type"`
}

// BetaBashTool20241022CacheControl0 defines model for .
type BetaBashTool20241022CacheControl0 struct {
	union json.RawMessage
}

// BetaBashTool20241022_CacheControl defines model for BetaBashTool20241022.CacheControl.
type BetaBashTool20241022_CacheControl struct {
	union json.RawMessage
}

// BetaBashTool20241022Name Name of the tool.
//
// This is how the tool will be called by the model and in tool_use blocks.
type BetaBashTool20241022Name string

// BetaBashTool20241022Type defines model for BetaBashTool20241022.Type.
type BetaBashTool20241022Type string

// BetaCacheControlEphemeral defines model for BetaCacheControlEphemeral.
type BetaCacheControlEphemeral struct {
	Type BetaCacheControlEphemeralType `json:"type"`
}

// BetaCacheControlEphemeralType defines model for BetaCacheControlEphemeral.Type.
type BetaCacheControlEphemeralType string

// BetaComputerUseTool20241022 defines model for BetaComputerUseTool_20241022.
type BetaComputerUseTool20241022 struct {
	CacheControl *BetaComputerUseTool20241022_CacheControl `json:"cache_control"`

	// DisplayHeightPx The height of the display in pixels.
	DisplayHeightPx int `json:"display_height_px"`

	// DisplayNumber The X11 display number (e.g. 0, 1) for the display.
	DisplayNumber *BetaComputerUseTool20241022_DisplayNumber `json:"display_number"`

	// DisplayWidthPx The width of the display in pixels.
	DisplayWidthPx int `json:"display_width_px"`

	// Name Name of the tool.
	//
	// This is how the tool will be called by the model and in tool_use blocks.
	Name BetaComputerUseTool20241022Name `json:"name"`
	Type BetaComputerUseTool20241022Type `json:"type"`
}

// BetaComputerUseTool20241022CacheControl0 defines model for .
type BetaComputerUseTool20241022CacheControl0 struct {
	union json.RawMessage
}

// BetaComputerUseTool20241022_CacheControl defines model for BetaComputerUseTool20241022.CacheControl.
type BetaComputerUseTool20241022_CacheControl struct {
	union json.RawMessage
}

// BetaComputerUseTool20241022DisplayNumber0 defines model for .
type BetaComputerUseTool20241022DisplayNumber0 = int

// BetaComputerUseTool20241022_DisplayNumber The X11 display number (e.g. 0, 1) for the display.
type BetaComputerUseTool20241022_DisplayNumber struct {
	union json.RawMessage
}

// BetaComputerUseTool20241022Name Name of the tool.
//
// This is how the tool will be called by the model and in tool_use blocks.
type BetaComputerUseTool20241022Name string

// BetaComputerUseTool20241022Type defines model for BetaComputerUseTool20241022.Type.
type BetaComputerUseTool20241022Type string

// BetaCountMessageTokensParams defines model for BetaCountMessageTokensParams.
type BetaCountMessageTokensParams struct {
	// Messages Input messages.
	//
	// Our models are trained to operate on alternating `user` and `assistant` conversational turns. When creating a new `Message`, you specify the prior conversational turns with the `messages` parameter, and the model then generates the next `Message` in the conversation. Consecutive `user` or `assistant` turns in your request will be combined into a single turn.
	//
	// Each input message must be an object with a `role` and `content`. You can specify a single `user`-role message, or you can include multiple `user` and `assistant` messages.
	//
	// If the final message uses the `assistant` role, the response content will continue immediately from the content in that message. This can be used to constrain part of the model's response.
	//
	// Example with a single `user` message:
	//
	// ```json
	// [{"role": "user", "content": "Hello, Claude"}]
	// ```
	//
	// Example with multiple conversational turns:
	//
	// ```json
	// [
	//   {"role": "user", "content": "Hello there."},
	//   {"role": "assistant", "content": "Hi, I'm Claude. How can I help you?"},
	//   {"role": "user", "content": "Can you explain LLMs in plain English?"},
	// ]
	// ```
	//
	// Example with a partially-filled response from Claude:
	//
	// ```json
	// [
	//   {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
	//   {"role": "assistant", "content": "The best answer is ("},
	// ]
	// ```
	//
	// Each input message `content` may be either a single `string` or an array of content blocks, where each block has a specific `type`. Using a `string` for `content` is shorthand for an array of one content block of type `"text"`. The following input messages are equivalent:
	//
	// ```json
	// {"role": "user", "content": "Hello, Claude"}
	// ```
	//
	// ```json
	// {"role": "user", "content": [{"type": "text", "text": "Hello, Claude"}]}
	// ```
	//
	// Starting with Claude 3 models, you can also send image content blocks:
	//
	// ```json
	// {"role": "user", "content": [
	//   {
	//     "type": "image",
	//     "source": {
	//       "type": "base64",
	//       "media_type": "image/jpeg",
	//       "data": "/9j/4AAQSkZJRg...",
	//     }
	//   },
	//   {"type": "text", "text": "What is in this image?"}
	// ]}
	// ```
	//
	// We currently support the `base64` source type for images, and the `image/jpeg`, `image/png`, `image/gif`, and `image/webp` media types.
	//
	// See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for more input examples.
	//
	// Note that if you want to include a [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use the top-level `system` parameter — there is no `"system"` role for input messages in the Messages API.
	Messages []BetaInputMessage `json:"messages"`

	// Model The model that will complete your prompt.\n\nSee [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
	Model Model `json:"model"`

	// System System prompt.
	//
	// A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
	System *BetaCountMessageTokensParams_System `json:"system,omitempty"`

	// ToolChoice How the model should use the provided tools. The model can use a specific tool, any available tool, or decide by itself.
	ToolChoice *BetaToolChoice `json:"tool_choice,omitempty"`

	// Tools Definitions of tools that the model may use.
	//
	// If you include `tools` in your API request, the model may return `tool_use` content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using `tool_result` content blocks.
	//
	// Each tool definition includes:
	//
	// * `name`: Name of the tool.
	// * `description`: Optional, but strongly-recommended description of the tool.
	// * `input_schema`: [JSON schema](https://json-schema.org/) for the tool `input` shape that the model will produce in `tool_use` output content blocks.
	//
	// For example, if you defined `tools` as:
	//
	// ```json
	// [
	//   {
	//     "name": "get_stock_price",
	//     "description": "Get the current stock price for a given ticker symbol.",
	//     "input_schema": {
	//       "type": "object",
	//       "properties": {
	//         "ticker": {
	//           "type": "string",
	//           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
	//         }
	//       },
	//       "required": ["ticker"]
	//     }
	//   }
	// ]
	// ```
	//
	// And then asked the model "What's the S&P 500 at today?", the model might produce `tool_use` content blocks in the response like this:
	//
	// ```json
	// [
	//   {
	//     "type": "tool_use",
	//     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
	//     "name": "get_stock_price",
	//     "input": { "ticker": "^GSPC" }
	//   }
	// ]
	// ```
	//
	// You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an input, and return the following back to the model in a subsequent `user` message:
	//
	// ```json
	// [
	//   {
	//     "type": "tool_result",
	//     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
	//     "content": "259.75 USD"
	//   }
	// ]
	// ```
	//
	// Tools can be used for workflows that include running client-side tools and functions, or more generally whenever you want the model to produce a particular JSON structure of output.
	//
	// See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
	Tools *[]BetaCountMessageTokensParams_Tools_Item `json:"tools,omitempty"`
}

// BetaCountMessageTokensParamsSystem0 defines model for .
type BetaCountMessageTokensParamsSystem0 = string

// BetaCountMessageTokensParamsSystem1 defines model for .
type BetaCountMessageTokensParamsSystem1 = []BetaRequestTextBlock

// BetaCountMessageTokensParams_System System prompt.
//
// A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
type BetaCountMessageTokensParams_System struct {
	union json.RawMessage
}

// BetaCountMessageTokensParams_Tools_Item defines model for BetaCountMessageTokensParams.tools.Item.
type BetaCountMessageTokensParams_Tools_Item struct {
	union json.RawMessage
}

// BetaCountMessageTokensResponse defines model for BetaCountMessageTokensResponse.
type BetaCountMessageTokensResponse struct {
	// InputTokens The total number of tokens across the provided list of messages, system prompt, and tools.
	InputTokens int `json:"input_tokens"`
}

// BetaCreateMessageBatchParams defines model for BetaCreateMessageBatchParams.
type BetaCreateMessageBatchParams struct {
	// Requests List of requests for prompt completion. Each is an individual request to create a Message.
	Requests []BetaMessageBatchIndividualRequestParams `json:"requests"`
}

// BetaCreateMessageParams defines model for BetaCreateMessageParams.
type BetaCreateMessageParams struct {
	// MaxTokens The maximum number of tokens to generate before stopping.
	//
	// Note that our models may stop _before_ reaching this maximum. This parameter only specifies the absolute maximum number of tokens to generate.
	//
	// Different models have different maximum values for this parameter.  See [models](https://docs.anthropic.com/en/docs/models-overview) for details.
	MaxTokens int `json:"max_tokens"`

	// Messages Input messages.
	//
	// Our models are trained to operate on alternating `user` and `assistant` conversational turns. When creating a new `Message`, you specify the prior conversational turns with the `messages` parameter, and the model then generates the next `Message` in the conversation. Consecutive `user` or `assistant` turns in your request will be combined into a single turn.
	//
	// Each input message must be an object with a `role` and `content`. You can specify a single `user`-role message, or you can include multiple `user` and `assistant` messages.
	//
	// If the final message uses the `assistant` role, the response content will continue immediately from the content in that message. This can be used to constrain part of the model's response.
	//
	// Example with a single `user` message:
	//
	// ```json
	// [{"role": "user", "content": "Hello, Claude"}]
	// ```
	//
	// Example with multiple conversational turns:
	//
	// ```json
	// [
	//   {"role": "user", "content": "Hello there."},
	//   {"role": "assistant", "content": "Hi, I'm Claude. How can I help you?"},
	//   {"role": "user", "content": "Can you explain LLMs in plain English?"},
	// ]
	// ```
	//
	// Example with a partially-filled response from Claude:
	//
	// ```json
	// [
	//   {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
	//   {"role": "assistant", "content": "The best answer is ("},
	// ]
	// ```
	//
	// Each input message `content` may be either a single `string` or an array of content blocks, where each block has a specific `type`. Using a `string` for `content` is shorthand for an array of one content block of type `"text"`. The following input messages are equivalent:
	//
	// ```json
	// {"role": "user", "content": "Hello, Claude"}
	// ```
	//
	// ```json
	// {"role": "user", "content": [{"type": "text", "text": "Hello, Claude"}]}
	// ```
	//
	// Starting with Claude 3 models, you can also send image content blocks:
	//
	// ```json
	// {"role": "user", "content": [
	//   {
	//     "type": "image",
	//     "source": {
	//       "type": "base64",
	//       "media_type": "image/jpeg",
	//       "data": "/9j/4AAQSkZJRg...",
	//     }
	//   },
	//   {"type": "text", "text": "What is in this image?"}
	// ]}
	// ```
	//
	// We currently support the `base64` source type for images, and the `image/jpeg`, `image/png`, `image/gif`, and `image/webp` media types.
	//
	// See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for more input examples.
	//
	// Note that if you want to include a [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use the top-level `system` parameter — there is no `"system"` role for input messages in the Messages API.
	Messages []BetaInputMessage `json:"messages"`

	// Metadata An object describing metadata about the request.
	Metadata *BetaMetadata `json:"metadata,omitempty"`

	// Model The model that will complete your prompt.\n\nSee [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
	Model Model `json:"model"`

	// StopSequences Custom text sequences that will cause the model to stop generating.
	//
	// Our models will normally stop when they have naturally completed their turn, which will result in a response `stop_reason` of `"end_turn"`.
	//
	// If you want the model to stop generating when it encounters custom strings of text, you can use the `stop_sequences` parameter. If the model encounters one of the custom sequences, the response `stop_reason` value will be `"stop_sequence"` and the response `stop_sequence` value will contain the matched stop sequence.
	StopSequences *[]string `json:"stop_sequences,omitempty"`

	// Stream Whether to incrementally stream the response using server-sent events.
	//
	// See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for details.
	Stream *bool `json:"stream,omitempty"`

	// System System prompt.
	//
	// A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
	System *BetaCreateMessageParams_System `json:"system,omitempty"`

	// Temperature Amount of randomness injected into the response.
	//
	// Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0` for analytical / multiple choice, and closer to `1.0` for creative and generative tasks.
	//
	// Note that even with `temperature` of `0.0`, the results will not be fully deterministic.
	Temperature *float32 `json:"temperature,omitempty"`

	// ToolChoice How the model should use the provided tools. The model can use a specific tool, any available tool, or decide by itself.
	ToolChoice *BetaToolChoice `json:"tool_choice,omitempty"`

	// Tools Definitions of tools that the model may use.
	//
	// If you include `tools` in your API request, the model may return `tool_use` content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using `tool_result` content blocks.
	//
	// Each tool definition includes:
	//
	// * `name`: Name of the tool.
	// * `description`: Optional, but strongly-recommended description of the tool.
	// * `input_schema`: [JSON schema](https://json-schema.org/) for the tool `input` shape that the model will produce in `tool_use` output content blocks.
	//
	// For example, if you defined `tools` as:
	//
	// ```json
	// [
	//   {
	//     "name": "get_stock_price",
	//     "description": "Get the current stock price for a given ticker symbol.",
	//     "input_schema": {
	//       "type": "object",
	//       "properties": {
	//         "ticker": {
	//           "type": "string",
	//           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
	//         }
	//       },
	//       "required": ["ticker"]
	//     }
	//   }
	// ]
	// ```
	//
	// And then asked the model "What's the S&P 500 at today?", the model might produce `tool_use` content blocks in the response like this:
	//
	// ```json
	// [
	//   {
	//     "type": "tool_use",
	//     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
	//     "name": "get_stock_price",
	//     "input": { "ticker": "^GSPC" }
	//   }
	// ]
	// ```
	//
	// You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an input, and return the following back to the model in a subsequent `user` message:
	//
	// ```json
	// [
	//   {
	//     "type": "tool_result",
	//     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
	//     "content": "259.75 USD"
	//   }
	// ]
	// ```
	//
	// Tools can be used for workflows that include running client-side tools and functions, or more generally whenever you want the model to produce a particular JSON structure of output.
	//
	// See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
	Tools *[]BetaCreateMessageParams_Tools_Item `json:"tools,omitempty"`

	// TopK Only sample from the top K options for each subsequent token.
	//
	// Used to remove "long tail" low probability responses. [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
	//
	// Recommended for advanced use cases only. You usually only need to use `temperature`.
	TopK *int `json:"top_k,omitempty"`

	// TopP Use nucleus sampling.
	//
	// In nucleus sampling, we compute the cumulative distribution over all the options for each subsequent token in decreasing probability order and cut it off once it reaches a particular probability specified by `top_p`. You should either alter `temperature` or `top_p`, but not both.
	//
	// Recommended for advanced use cases only. You usually only need to use `temperature`.
	TopP *float32 `json:"top_p,omitempty"`
}

// BetaCreateMessageParamsSystem0 defines model for .
type BetaCreateMessageParamsSystem0 = string

// BetaCreateMessageParamsSystem1 defines model for .
type BetaCreateMessageParamsSystem1 = []BetaRequestTextBlock

// BetaCreateMessageParams_System System prompt.
//
// A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
type BetaCreateMessageParams_System struct {
	union json.RawMessage
}

// BetaCreateMessageParams_Tools_Item defines model for BetaCreateMessageParams.tools.Item.
type BetaCreateMessageParams_Tools_Item struct {
	union json.RawMessage
}

// BetaErrorResponse defines model for BetaErrorResponse.
type BetaErrorResponse struct {
	Error BetaErrorResponse_Error `json:"error"`
	Type  BetaErrorResponseType   `json:"type"`
}

// BetaErrorResponse_Error defines model for BetaErrorResponse.Error.
type BetaErrorResponse_Error struct {
	union json.RawMessage
}

// BetaErrorResponseType defines model for BetaErrorResponse.Type.
type BetaErrorResponseType string

// BetaInputContentBlock defines model for BetaInputContentBlock.
type BetaInputContentBlock struct {
	union json.RawMessage
}

// BetaInputMessage defines model for BetaInputMessage.
type BetaInputMessage struct {
	Content BetaInputMessage_Content `json:"content"`
	Role    BetaInputMessageRole     `json:"role"`
}

// BetaInputMessageContent0 defines model for .
type BetaInputMessageContent0 = string

// BetaInputMessageContent1 defines model for .
type BetaInputMessageContent1 = []BetaInputContentBlock

// BetaInputMessage_Content defines model for BetaInputMessage.Content.
type BetaInputMessage_Content struct {
	union json.RawMessage
}

// BetaInputMessageRole defines model for BetaInputMessage.Role.
type BetaInputMessageRole string

// BetaInputSchema defines model for BetaInputSchema.
type BetaInputSchema struct {
	Properties           *BetaInputSchema_Properties `json:"properties"`
	Type                 BetaInputSchemaType         `json:"type"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// BetaInputSchemaProperties0 defines model for .
type BetaInputSchemaProperties0 = map[string]interface{}

// BetaInputSchema_Properties defines model for BetaInputSchema.Properties.
type BetaInputSchema_Properties struct {
	union json.RawMessage
}

// BetaInputSchemaType defines model for BetaInputSchema.Type.
type BetaInputSchemaType string

// BetaInvalidRequestError defines model for BetaInvalidRequestError.
type BetaInvalidRequestError struct {
	Message string                      `json:"message"`
	Type    BetaInvalidRequestErrorType `json:"type"`
}

// BetaInvalidRequestErrorType defines model for BetaInvalidRequestError.Type.
type BetaInvalidRequestErrorType string

// BetaListResponseMessageBatch defines model for BetaListResponse_MessageBatch_.
type BetaListResponseMessageBatch struct {
	Data []BetaMessageBatch `json:"data"`

	// FirstId First ID in the `data` list. Can be used as the `before_id` for the previous page.
	FirstId *BetaListResponseMessageBatch_FirstId `json:"first_id"`

	// HasMore Indicates if there are more results in the requested page direction.
	HasMore bool `json:"has_more"`

	// LastId Last ID in the `data` list. Can be used as the `after_id` for the next page.
	LastId *BetaListResponseMessageBatch_LastId `json:"last_id"`
}

// BetaListResponseMessageBatchFirstId0 defines model for .
type BetaListResponseMessageBatchFirstId0 = string

// BetaListResponseMessageBatch_FirstId First ID in the `data` list. Can be used as the `before_id` for the previous page.
type BetaListResponseMessageBatch_FirstId struct {
	union json.RawMessage
}

// BetaListResponseMessageBatchLastId0 defines model for .
type BetaListResponseMessageBatchLastId0 = string

// BetaListResponseMessageBatch_LastId Last ID in the `data` list. Can be used as the `after_id` for the next page.
type BetaListResponseMessageBatch_LastId struct {
	union json.RawMessage
}

// BetaMessageBatch defines model for BetaMessageBatch.
type BetaMessageBatch struct {
	// ArchivedAt RFC 3339 datetime string representing the time at which the Message Batch was archived and its results became unavailable.
	ArchivedAt *BetaMessageBatch_ArchivedAt `json:"archived_at"`

	// CancelInitiatedAt RFC 3339 datetime string representing the time at which cancellation was initiated for the Message Batch. Specified only if cancellation was initiated.
	CancelInitiatedAt *BetaMessageBatch_CancelInitiatedAt `json:"cancel_initiated_at"`

	// CreatedAt RFC 3339 datetime string representing the time at which the Message Batch was created.
	CreatedAt time.Time `json:"created_at"`

	// EndedAt RFC 3339 datetime string representing the time at which processing for the Message Batch ended. Specified only once processing ends.
	//
	// Processing ends when every request in a Message Batch has either succeeded, errored, canceled, or expired.
	EndedAt *BetaMessageBatch_EndedAt `json:"ended_at"`

	// ExpiresAt RFC 3339 datetime string representing the time at which the Message Batch will expire and end processing, which is 24 hours after creation.
	ExpiresAt time.Time `json:"expires_at"`

	// Id Unique object identifier.
	//
	// The format and length of IDs may change over time.
	Id string `json:"id"`

	// ProcessingStatus Processing status of the Message Batch.
	ProcessingStatus BetaMessageBatchProcessingStatus `json:"processing_status"`

	// RequestCounts Tallies requests within the Message Batch, categorized by their status.
	//
	// Requests start as `processing` and move to one of the other statuses only once processing of the entire batch ends. The sum of all values always matches the total number of requests in the batch.
	RequestCounts BetaRequestCounts `json:"request_counts"`

	// ResultsUrl URL to a `.jsonl` file containing the results of the Message Batch requests. Specified only once processing ends.
	//
	// Results in the file are not guaranteed to be in the same order as requests. Use the `custom_id` field to match results to requests.
	ResultsUrl *BetaMessageBatch_ResultsUrl `json:"results_url"`

	// Type Object type.
	//
	// For Message Batches, this is always `"message_batch"`.
	Type BetaMessageBatchType `json:"type"`
}

// BetaMessageBatchArchivedAt0 defines model for .
type BetaMessageBatchArchivedAt0 = time.Time

// BetaMessageBatch_ArchivedAt RFC 3339 datetime string representing the time at which the Message Batch was archived and its results became unavailable.
type BetaMessageBatch_ArchivedAt struct {
	union json.RawMessage
}

// BetaMessageBatchCancelInitiatedAt0 defines model for .
type BetaMessageBatchCancelInitiatedAt0 = time.Time

// BetaMessageBatch_CancelInitiatedAt RFC 3339 datetime string representing the time at which cancellation was initiated for the Message Batch. Specified only if cancellation was initiated.
type BetaMessageBatch_CancelInitiatedAt struct {
	union json.RawMessage
}

// BetaMessageBatchEndedAt0 defines model for .
type BetaMessageBatchEndedAt0 = time.Time

// BetaMessageBatch_EndedAt RFC 3339 datetime string representing the time at which processing for the Message Batch ended. Specified only once processing ends.
//
// Processing ends when every request in a Message Batch has either succeeded, errored, canceled, or expired.
type BetaMessageBatch_EndedAt struct {
	union json.RawMessage
}

// BetaMessageBatchProcessingStatus Processing status of the Message Batch.
type BetaMessageBatchProcessingStatus string

// BetaMessageBatchResultsUrl0 defines model for .
type BetaMessageBatchResultsUrl0 = string

// BetaMessageBatch_ResultsUrl URL to a `.jsonl` file containing the results of the Message Batch requests. Specified only once processing ends.
//
// Results in the file are not guaranteed to be in the same order as requests. Use the `custom_id` field to match results to requests.
type BetaMessageBatch_ResultsUrl struct {
	union json.RawMessage
}

// BetaMessageBatchType Object type.
//
// For Message Batches, this is always `"message_batch"`.
type BetaMessageBatchType string

// BetaMessageBatchIndividualRequestParams defines model for BetaMessageBatchIndividualRequestParams.
type BetaMessageBatchIndividualRequestParams struct {
	// CustomId Developer-provided ID created for each request in a Message Batch. Useful for matching results to requests, as results may be given out of request order.
	//
	// Must be unique for each request within the Message Batch.
	CustomId string `json:"custom_id"`

	// Params Messages API creation parameters for the individual request.
	//
	// See the [Messages API reference](/en/api/messages) for full documentation on available parameters.
	Params BetaCreateMessageParams `json:"params"`
}

// BetaMetadata defines model for BetaMetadata.
type BetaMetadata struct {
	// UserId An external identifier for the user who is associated with the request.
	//
	// This should be a uuid, hash value, or other opaque identifier. Anthropic may use this id to help detect abuse. Do not include any identifying information such as name, email address, or phone number.
	UserId *BetaMetadata_UserId `json:"user_id"`
}

// BetaMetadataUserId0 defines model for .
type BetaMetadataUserId0 = string

// BetaMetadata_UserId An external identifier for the user who is associated with the request.
//
// This should be a uuid, hash value, or other opaque identifier. Anthropic may use this id to help detect abuse. Do not include any identifying information such as name, email address, or phone number.
type BetaMetadata_UserId struct {
	union json.RawMessage
}

// BetaNotFoundError defines model for BetaNotFoundError.
type BetaNotFoundError struct {
	Message string                `json:"message"`
	Type    BetaNotFoundErrorType `json:"type"`
}

// BetaNotFoundErrorType defines model for BetaNotFoundError.Type.
type BetaNotFoundErrorType string

// BetaOverloadedError defines model for BetaOverloadedError.
type BetaOverloadedError struct {
	Message string                  `json:"message"`
	Type    BetaOverloadedErrorType `json:"type"`
}

// BetaOverloadedErrorType defines model for BetaOverloadedError.Type.
type BetaOverloadedErrorType string

// BetaPermissionError defines model for BetaPermissionError.
type BetaPermissionError struct {
	Message string                  `json:"message"`
	Type    BetaPermissionErrorType `json:"type"`
}

// BetaPermissionErrorType defines model for BetaPermissionError.Type.
type BetaPermissionErrorType string

// BetaRateLimitError defines model for BetaRateLimitError.
type BetaRateLimitError struct {
	Message string                 `json:"message"`
	Type    BetaRateLimitErrorType `json:"type"`
}

// BetaRateLimitErrorType defines model for BetaRateLimitError.Type.
type BetaRateLimitErrorType string

// BetaRequestCounts defines model for BetaRequestCounts.
type BetaRequestCounts struct {
	// Canceled Number of requests in the Message Batch that have been canceled.
	//
	// This is zero until processing of the entire Message Batch has ended.
	Canceled int `json:"canceled"`

	// Errored Number of requests in the Message Batch that encountered an error.
	//
	// This is zero until processing of the entire Message Batch has ended.
	Errored int `json:"errored"`

	// Expired Number of requests in the Message Batch that have expired.
	//
	// This is zero until processing of the entire Message Batch has ended.
	Expired int `json:"expired"`

	// Processing Number of requests in the Message Batch that are processing.
	Processing int `json:"processing"`

	// Succeeded Number of requests in the Message Batch that have completed successfully.
	//
	// This is zero until processing of the entire Message Batch has ended.
	Succeeded int `json:"succeeded"`
}

// BetaRequestImageBlock defines model for BetaRequestImageBlock.
type BetaRequestImageBlock struct {
	CacheControl *BetaRequestImageBlock_CacheControl `json:"cache_control"`
	Source       BetaRequestImageBlock_Source        `json:"source"`
	Type         BetaRequestImageBlockType           `json:"type"`
}

// BetaRequestImageBlockCacheControl0 defines model for .
type BetaRequestImageBlockCacheControl0 struct {
	union json.RawMessage
}

// BetaRequestImageBlock_CacheControl defines model for BetaRequestImageBlock.CacheControl.
type BetaRequestImageBlock_CacheControl struct {
	union json.RawMessage
}

// BetaRequestImageBlock_Source defines model for BetaRequestImageBlock.Source.
type BetaRequestImageBlock_Source struct {
	union json.RawMessage
}

// BetaRequestImageBlockType defines model for BetaRequestImageBlock.Type.
type BetaRequestImageBlockType string

// BetaRequestPDFBlock defines model for BetaRequestPDFBlock.
type BetaRequestPDFBlock struct {
	CacheControl *BetaRequestPDFBlock_CacheControl `json:"cache_control"`
	Source       BetaBase64PDFSource               `json:"source"`
	Type         BetaRequestPDFBlockType           `json:"type"`
}

// BetaRequestPDFBlockCacheControl0 defines model for .
type BetaRequestPDFBlockCacheControl0 struct {
	union json.RawMessage
}

// BetaRequestPDFBlock_CacheControl defines model for BetaRequestPDFBlock.CacheControl.
type BetaRequestPDFBlock_CacheControl struct {
	union json.RawMessage
}

// BetaRequestPDFBlockType defines model for BetaRequestPDFBlock.Type.
type BetaRequestPDFBlockType string

// BetaRequestTextBlock defines model for BetaRequestTextBlock.
type BetaRequestTextBlock struct {
	CacheControl *BetaRequestTextBlock_CacheControl `json:"cache_control"`
	Text         string                             `json:"text"`
	Type         BetaRequestTextBlockType           `json:"type"`
}

// BetaRequestTextBlockCacheControl0 defines model for .
type BetaRequestTextBlockCacheControl0 struct {
	union json.RawMessage
}

// BetaRequestTextBlock_CacheControl defines model for BetaRequestTextBlock.CacheControl.
type BetaRequestTextBlock_CacheControl struct {
	union json.RawMessage
}

// BetaRequestTextBlockType defines model for BetaRequestTextBlock.Type.
type BetaRequestTextBlockType string

// BetaRequestToolResultBlock defines model for BetaRequestToolResultBlock.
type BetaRequestToolResultBlock struct {
	CacheControl *BetaRequestToolResultBlock_CacheControl `json:"cache_control"`
	Content      *BetaRequestToolResultBlock_Content      `json:"content,omitempty"`
	IsError      *bool                                    `json:"is_error,omitempty"`
	ToolUseId    string                                   `json:"tool_use_id"`
	Type         BetaRequestToolResultBlockType           `json:"type"`
}

// BetaRequestToolResultBlockCacheControl0 defines model for .
type BetaRequestToolResultBlockCacheControl0 struct {
	union json.RawMessage
}

// BetaRequestToolResultBlock_CacheControl defines model for BetaRequestToolResultBlock.CacheControl.
type BetaRequestToolResultBlock_CacheControl struct {
	union json.RawMessage
}

// BetaRequestToolResultBlockContent0 defines model for .
type BetaRequestToolResultBlockContent0 = string

// BetaRequestToolResultBlockContent1 defines model for .
type BetaRequestToolResultBlockContent1 = []BetaRequestToolResultBlock_Content_1_Item

// BetaRequestToolResultBlock_Content_1_Item defines model for BetaRequestToolResultBlock.Content.1.Item.
type BetaRequestToolResultBlock_Content_1_Item struct {
	union json.RawMessage
}

// BetaRequestToolResultBlock_Content defines model for BetaRequestToolResultBlock.Content.
type BetaRequestToolResultBlock_Content struct {
	union json.RawMessage
}

// BetaRequestToolResultBlockType defines model for BetaRequestToolResultBlock.Type.
type BetaRequestToolResultBlockType string

// BetaRequestToolUseBlock defines model for BetaRequestToolUseBlock.
type BetaRequestToolUseBlock struct {
	CacheControl *BetaRequestToolUseBlock_CacheControl `json:"cache_control"`
	Id           string                                `json:"id"`
	Input        map[string]interface{}                `json:"input"`
	Name         string                                `json:"name"`
	Type         BetaRequestToolUseBlockType           `json:"type"`
}

// BetaRequestToolUseBlockCacheControl0 defines model for .
type BetaRequestToolUseBlockCacheControl0 struct {
	union json.RawMessage
}

// BetaRequestToolUseBlock_CacheControl defines model for BetaRequestToolUseBlock.CacheControl.
type BetaRequestToolUseBlock_CacheControl struct {
	union json.RawMessage
}

// BetaRequestToolUseBlockType defines model for BetaRequestToolUseBlock.Type.
type BetaRequestToolUseBlockType string

// BetaTextEditor20241022 defines model for BetaTextEditor_20241022.
type BetaTextEditor20241022 struct {
	CacheControl *BetaTextEditor20241022_CacheControl `json:"cache_control"`

	// Name Name of the tool.
	//
	// This is how the tool will be called by the model and in tool_use blocks.
	Name BetaTextEditor20241022Name `json:"name"`
	Type BetaTextEditor20241022Type `json:"type"`
}

// BetaTextEditor20241022CacheControl0 defines model for .
type BetaTextEditor20241022CacheControl0 struct {
	union json.RawMessage
}

// BetaTextEditor20241022_CacheControl defines model for BetaTextEditor20241022.CacheControl.
type BetaTextEditor20241022_CacheControl struct {
	union json.RawMessage
}

// BetaTextEditor20241022Name Name of the tool.
//
// This is how the tool will be called by the model and in tool_use blocks.
type BetaTextEditor20241022Name string

// BetaTextEditor20241022Type defines model for BetaTextEditor20241022.Type.
type BetaTextEditor20241022Type string

// BetaTool defines model for BetaTool.
type BetaTool struct {
	CacheControl *BetaTool_CacheControl `json:"cache_control"`

	// Description Description of what this tool does.
	//
	// Tool descriptions should be as detailed as possible. The more information that the model has about what the tool is and how to use it, the better it will perform. You can use natural language descriptions to reinforce important aspects of the tool input JSON schema.
	Description *string `json:"description,omitempty"`

	// InputSchema [JSON schema](https://json-schema.org/) for this tool's input.
	//
	// This defines the shape of the `input` that your tool accepts and that the model will produce.
	InputSchema BetaInputSchema `json:"input_schema"`

	// Name Name of the tool.
	//
	// This is how the tool will be called by the model and in tool_use blocks.
	Name string         `json:"name"`
	Type *BetaTool_Type `json:"type"`
}

// BetaToolCacheControl0 defines model for .
type BetaToolCacheControl0 struct {
	union json.RawMessage
}

// BetaTool_CacheControl defines model for BetaTool.CacheControl.
type BetaTool_CacheControl struct {
	union json.RawMessage
}

// BetaToolType0 defines model for BetaTool.Type.0.
type BetaToolType0 string

// BetaTool_Type defines model for BetaTool.Type.
type BetaTool_Type struct {
	union json.RawMessage
}

// BetaToolChoice How the model should use the provided tools. The model can use a specific tool, any available tool, or decide by itself.
type BetaToolChoice struct {
	union json.RawMessage
}

// BetaToolChoiceAny The model will use any available tools.
type BetaToolChoiceAny struct {
	// DisableParallelToolUse Whether to disable parallel tool use.
	//
	// Defaults to `false`. If set to `true`, the model will output exactly one tool use.
	DisableParallelToolUse *bool                 `json:"disable_parallel_tool_use,omitempty"`
	Type                   BetaToolChoiceAnyType `json:"type"`
}

// BetaToolChoiceAnyType defines model for BetaToolChoiceAny.Type.
type BetaToolChoiceAnyType string

// BetaToolChoiceAuto The model will automatically decide whether to use tools.
type BetaToolChoiceAuto struct {
	// DisableParallelToolUse Whether to disable parallel tool use.
	//
	// Defaults to `false`. If set to `true`, the model will output at most one tool use.
	DisableParallelToolUse *bool                  `json:"disable_parallel_tool_use,omitempty"`
	Type                   BetaToolChoiceAutoType `json:"type"`
}

// BetaToolChoiceAutoType defines model for BetaToolChoiceAuto.Type.
type BetaToolChoiceAutoType string

// BetaToolChoiceTool The model will use the specified tool with `tool_choice.name`.
type BetaToolChoiceTool struct {
	// DisableParallelToolUse Whether to disable parallel tool use.
	//
	// Defaults to `false`. If set to `true`, the model will output exactly one tool use.
	DisableParallelToolUse *bool `json:"disable_parallel_tool_use,omitempty"`

	// Name The name of the tool to use.
	Name string                 `json:"name"`
	Type BetaToolChoiceToolType `json:"type"`
}

// BetaToolChoiceToolType defines model for BetaToolChoiceTool.Type.
type BetaToolChoiceToolType string

// CacheControlEphemeral defines model for CacheControlEphemeral.
type CacheControlEphemeral struct {
	Type CacheControlEphemeralType `json:"type"`
}

// CacheControlEphemeralType defines model for CacheControlEphemeral.Type.
type CacheControlEphemeralType string

// CompletionRequest defines model for CompletionRequest.
type CompletionRequest struct {
	// MaxTokensToSample The maximum number of tokens to generate before stopping.
	//
	// Note that our models may stop _before_ reaching this maximum. This parameter only specifies the absolute maximum number of tokens to generate.
	MaxTokensToSample int `json:"max_tokens_to_sample"`

	// Metadata An object describing metadata about the request.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Model The model that will complete your prompt.\n\nSee [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
	Model Model `json:"model"`

	// Prompt The prompt that you want Claude to complete.
	//
	// For proper response generation you will need to format your prompt using alternating `\n\nHuman:` and `\n\nAssistant:` conversational turns. For example:
	//
	// ```
	// "\n\nHuman: {userQuestion}\n\nAssistant:"
	// ```
	//
	// See [prompt validation](https://docs.anthropic.com/en/api/prompt-validation) and our guide to [prompt design](https://docs.anthropic.com/en/docs/intro-to-prompting) for more details.
	Prompt string `json:"prompt"`

	// StopSequences Sequences that will cause the model to stop generating.
	//
	// Our models stop on `"\n\nHuman:"`, and may include additional built-in stop sequences in the future. By providing the stop_sequences parameter, you may include additional strings that will cause the model to stop generating.
	StopSequences *[]string `json:"stop_sequences,omitempty"`

	// Stream Whether to incrementally stream the response using server-sent events.
	//
	// See [streaming](https://docs.anthropic.com/en/api/streaming) for details.
	Stream *bool `json:"stream,omitempty"`

	// Temperature Amount of randomness injected into the response.
	//
	// Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0` for analytical / multiple choice, and closer to `1.0` for creative and generative tasks.
	//
	// Note that even with `temperature` of `0.0`, the results will not be fully deterministic.
	Temperature *float32 `json:"temperature,omitempty"`

	// TopK Only sample from the top K options for each subsequent token.
	//
	// Used to remove "long tail" low probability responses. [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
	//
	// Recommended for advanced use cases only. You usually only need to use `temperature`.
	TopK *int `json:"top_k,omitempty"`

	// TopP Use nucleus sampling.
	//
	// In nucleus sampling, we compute the cumulative distribution over all the options for each subsequent token in decreasing probability order and cut it off once it reaches a particular probability specified by `top_p`. You should either alter `temperature` or `top_p`, but not both.
	//
	// Recommended for advanced use cases only. You usually only need to use `temperature`.
	TopP *float32 `json:"top_p,omitempty"`
}

// CompletionResponse defines model for CompletionResponse.
type CompletionResponse struct {
	// Completion The resulting completion up to and excluding the stop sequences.
	Completion string `json:"completion"`

	// Id Unique object identifier.
	//
	// The format and length of IDs may change over time.
	Id string `json:"id"`

	// Model The model that will complete your prompt.\n\nSee [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
	Model Model `json:"model"`

	// StopReason The reason that we stopped.
	//
	// This may be one the following values:
	// * `"stop_sequence"`: we reached a stop sequence — either provided by you via the `stop_sequences` parameter, or a stop sequence built into the model
	// * `"max_tokens"`: we exceeded `max_tokens_to_sample` or the model's maximum
	StopReason *CompletionResponse_StopReason `json:"stop_reason"`

	// Type Object type.
	//
	// For Text Completions, this is always `"completion"`.
	Type CompletionResponseType `json:"type"`
}

// CompletionResponseStopReason0 defines model for .
type CompletionResponseStopReason0 = string

// CompletionResponse_StopReason The reason that we stopped.
//
// This may be one the following values:
// * `"stop_sequence"`: we reached a stop sequence — either provided by you via the `stop_sequences` parameter, or a stop sequence built into the model
// * `"max_tokens"`: we exceeded `max_tokens_to_sample` or the model's maximum
type CompletionResponse_StopReason struct {
	union json.RawMessage
}

// CompletionResponseType Object type.
//
// For Text Completions, this is always `"completion"`.
type CompletionResponseType string

// ContentBlock defines model for ContentBlock.
type ContentBlock struct {
	union json.RawMessage
}

// CreateMessageParams defines model for CreateMessageParams.
type CreateMessageParams struct {
	// MaxTokens The maximum number of tokens to generate before stopping.
	//
	// Note that our models may stop _before_ reaching this maximum. This parameter only specifies the absolute maximum number of tokens to generate.
	//
	// Different models have different maximum values for this parameter.  See [models](https://docs.anthropic.com/en/docs/models-overview) for details.
	MaxTokens int `json:"max_tokens"`

	// Messages Input messages.
	//
	// Our models are trained to operate on alternating `user` and `assistant` conversational turns. When creating a new `Message`, you specify the prior conversational turns with the `messages` parameter, and the model then generates the next `Message` in the conversation. Consecutive `user` or `assistant` turns in your request will be combined into a single turn.
	//
	// Each input message must be an object with a `role` and `content`. You can specify a single `user`-role message, or you can include multiple `user` and `assistant` messages.
	//
	// If the final message uses the `assistant` role, the response content will continue immediately from the content in that message. This can be used to constrain part of the model's response.
	//
	// Example with a single `user` message:
	//
	// ```json
	// [{"role": "user", "content": "Hello, Claude"}]
	// ```
	//
	// Example with multiple conversational turns:
	//
	// ```json
	// [
	//   {"role": "user", "content": "Hello there."},
	//   {"role": "assistant", "content": "Hi, I'm Claude. How can I help you?"},
	//   {"role": "user", "content": "Can you explain LLMs in plain English?"},
	// ]
	// ```
	//
	// Example with a partially-filled response from Claude:
	//
	// ```json
	// [
	//   {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
	//   {"role": "assistant", "content": "The best answer is ("},
	// ]
	// ```
	//
	// Each input message `content` may be either a single `string` or an array of content blocks, where each block has a specific `type`. Using a `string` for `content` is shorthand for an array of one content block of type `"text"`. The following input messages are equivalent:
	//
	// ```json
	// {"role": "user", "content": "Hello, Claude"}
	// ```
	//
	// ```json
	// {"role": "user", "content": [{"type": "text", "text": "Hello, Claude"}]}
	// ```
	//
	// Starting with Claude 3 models, you can also send image content blocks:
	//
	// ```json
	// {"role": "user", "content": [
	//   {
	//     "type": "image",
	//     "source": {
	//       "type": "base64",
	//       "media_type": "image/jpeg",
	//       "data": "/9j/4AAQSkZJRg...",
	//     }
	//   },
	//   {"type": "text", "text": "What is in this image?"}
	// ]}
	// ```
	//
	// We currently support the `base64` source type for images, and the `image/jpeg`, `image/png`, `image/gif`, and `image/webp` media types.
	//
	// See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for more input examples.
	//
	// Note that if you want to include a [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use the top-level `system` parameter — there is no `"system"` role for input messages in the Messages API.
	Messages []InputMessage `json:"messages"`

	// Metadata An object describing metadata about the request.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Model The model that will complete your prompt.\n\nSee [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
	Model Model `json:"model"`

	// StopSequences Custom text sequences that will cause the model to stop generating.
	//
	// Our models will normally stop when they have naturally completed their turn, which will result in a response `stop_reason` of `"end_turn"`.
	//
	// If you want the model to stop generating when it encounters custom strings of text, you can use the `stop_sequences` parameter. If the model encounters one of the custom sequences, the response `stop_reason` value will be `"stop_sequence"` and the response `stop_sequence` value will contain the matched stop sequence.
	StopSequences *[]string `json:"stop_sequences,omitempty"`

	// Stream Whether to incrementally stream the response using server-sent events.
	//
	// See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for details.
	Stream *bool `json:"stream,omitempty"`

	// System System prompt.
	//
	// A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
	System *CreateMessageParams_System `json:"system,omitempty"`

	// Temperature Amount of randomness injected into the response.
	//
	// Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0` for analytical / multiple choice, and closer to `1.0` for creative and generative tasks.
	//
	// Note that even with `temperature` of `0.0`, the results will not be fully deterministic.
	Temperature *float32 `json:"temperature,omitempty"`

	// ToolChoice How the model should use the provided tools. The model can use a specific tool, any available tool, or decide by itself.
	ToolChoice *ToolChoice `json:"tool_choice,omitempty"`

	// Tools Definitions of tools that the model may use.
	//
	// If you include `tools` in your API request, the model may return `tool_use` content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using `tool_result` content blocks.
	//
	// Each tool definition includes:
	//
	// * `name`: Name of the tool.
	// * `description`: Optional, but strongly-recommended description of the tool.
	// * `input_schema`: [JSON schema](https://json-schema.org/) for the tool `input` shape that the model will produce in `tool_use` output content blocks.
	//
	// For example, if you defined `tools` as:
	//
	// ```json
	// [
	//   {
	//     "name": "get_stock_price",
	//     "description": "Get the current stock price for a given ticker symbol.",
	//     "input_schema": {
	//       "type": "object",
	//       "properties": {
	//         "ticker": {
	//           "type": "string",
	//           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
	//         }
	//       },
	//       "required": ["ticker"]
	//     }
	//   }
	// ]
	// ```
	//
	// And then asked the model "What's the S&P 500 at today?", the model might produce `tool_use` content blocks in the response like this:
	//
	// ```json
	// [
	//   {
	//     "type": "tool_use",
	//     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
	//     "name": "get_stock_price",
	//     "input": { "ticker": "^GSPC" }
	//   }
	// ]
	// ```
	//
	// You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an input, and return the following back to the model in a subsequent `user` message:
	//
	// ```json
	// [
	//   {
	//     "type": "tool_result",
	//     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
	//     "content": "259.75 USD"
	//   }
	// ]
	// ```
	//
	// Tools can be used for workflows that include running client-side tools and functions, or more generally whenever you want the model to produce a particular JSON structure of output.
	//
	// See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
	Tools *[]Tool `json:"tools,omitempty"`

	// TopK Only sample from the top K options for each subsequent token.
	//
	// Used to remove "long tail" low probability responses. [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
	//
	// Recommended for advanced use cases only. You usually only need to use `temperature`.
	TopK *int `json:"top_k,omitempty"`

	// TopP Use nucleus sampling.
	//
	// In nucleus sampling, we compute the cumulative distribution over all the options for each subsequent token in decreasing probability order and cut it off once it reaches a particular probability specified by `top_p`. You should either alter `temperature` or `top_p`, but not both.
	//
	// Recommended for advanced use cases only. You usually only need to use `temperature`.
	TopP *float32 `json:"top_p,omitempty"`
}

// CreateMessageParamsSystem0 defines model for .
type CreateMessageParamsSystem0 = string

// CreateMessageParamsSystem1 defines model for .
type CreateMessageParamsSystem1 = []RequestTextBlock

// CreateMessageParams_System System prompt.
//
// A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
type CreateMessageParams_System struct {
	union json.RawMessage
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error ErrorResponse_Error `json:"error"`
	Type  ErrorResponseType   `json:"type"`
}

// ErrorResponse_Error defines model for ErrorResponse.Error.
type ErrorResponse_Error struct {
	union json.RawMessage
}

// ErrorResponseType defines model for ErrorResponse.Type.
type ErrorResponseType string

// InputMessage defines model for InputMessage.
type InputMessage struct {
	Content InputMessage_Content `json:"content"`
	Role    InputMessageRole     `json:"role"`
}

// InputMessageContent0 defines model for .
type InputMessageContent0 = string

// InputMessageContent1 defines model for .
type InputMessageContent1 = []InputMessage_Content_1_Item

// InputMessage_Content_1_Item defines model for InputMessage.Content.1.Item.
type InputMessage_Content_1_Item struct {
	union json.RawMessage
}

// InputMessage_Content defines model for InputMessage.Content.
type InputMessage_Content struct {
	union json.RawMessage
}

// InputMessageRole defines model for InputMessage.Role.
type InputMessageRole string

// InputSchema defines model for InputSchema.
type InputSchema struct {
	Properties           *InputSchema_Properties `json:"properties"`
	Type                 InputSchemaType         `json:"type"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// InputSchemaProperties0 defines model for .
type InputSchemaProperties0 = map[string]interface{}

// InputSchema_Properties defines model for InputSchema.Properties.
type InputSchema_Properties struct {
	union json.RawMessage
}

// InputSchemaType defines model for InputSchema.Type.
type InputSchemaType string

// InvalidRequestError defines model for InvalidRequestError.
type InvalidRequestError struct {
	Message string                  `json:"message"`
	Type    InvalidRequestErrorType `json:"type"`
}

// InvalidRequestErrorType defines model for InvalidRequestError.Type.
type InvalidRequestErrorType string

// Message defines model for Message.
type Message struct {
	// Content Content generated by the model.
	//
	// This is an array of content blocks, each of which has a `type` that determines its shape.
	//
	// Example:
	//
	// ```json
	// [{"type": "text", "text": "Hi, I'm Claude."}]
	// ```
	//
	// If the request input `messages` ended with an `assistant` turn, then the response `content` will continue directly from that last turn. You can use this to constrain the model's output.
	//
	// For example, if the input `messages` were:
	// ```json
	// [
	//   {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
	//   {"role": "assistant", "content": "The best answer is ("}
	// ]
	// ```
	//
	// Then the response `content` might be:
	//
	// ```json
	// [{"type": "text", "text": "B)"}]
	// ```
	Content []ContentBlock `json:"content"`

	// Id Unique object identifier.
	//
	// The format and length of IDs may change over time.
	Id string `json:"id"`

	// Model The model that will complete your prompt.\n\nSee [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
	Model Model `json:"model"`

	// Role Conversational role of the generated message.
	//
	// This will always be `"assistant"`.
	Role MessageRole `json:"role"`

	// StopReason The reason that we stopped.
	//
	// This may be one the following values:
	// * `"end_turn"`: the model reached a natural stopping point
	// * `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
	// * `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
	// * `"tool_use"`: the model invoked one or more tools
	//
	// In non-streaming mode this value is always non-null. In streaming mode, it is null in the `message_start` event and non-null otherwise.
	StopReason *Message_StopReason `json:"stop_reason"`

	// StopSequence Which custom stop sequence was generated, if any.
	//
	// This value will be a non-null string if one of your custom stop sequences was generated.
	StopSequence *Message_StopSequence `json:"stop_sequence"`

	// Type Object type.
	//
	// For Messages, this is always `"message"`.
	Type MessageType `json:"type"`

	// Usage Billing and rate-limit usage.
	//
	// Anthropic's API bills and rate-limits by token counts, as tokens represent the underlying cost to our systems.
	//
	// Under the hood, the API transforms requests into a format suitable for the model. The model's output then goes through a parsing stage before becoming an API response. As a result, the token counts in `usage` will not match one-to-one with the exact visible content of an API request or response.
	//
	// For example, `output_tokens` will be non-zero, even for an empty string response from Claude.
	Usage Usage `json:"usage"`
}

// MessageRole Conversational role of the generated message.
//
// This will always be `"assistant"`.
type MessageRole string

// MessageStopReason0 defines model for Message.StopReason.0.
type MessageStopReason0 string

// Message_StopReason The reason that we stopped.
//
// This may be one the following values:
// * `"end_turn"`: the model reached a natural stopping point
// * `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
// * `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
// * `"tool_use"`: the model invoked one or more tools
//
// In non-streaming mode this value is always non-null. In streaming mode, it is null in the `message_start` event and non-null otherwise.
type Message_StopReason struct {
	union json.RawMessage
}

// MessageStopSequence0 defines model for .
type MessageStopSequence0 = string

// Message_StopSequence Which custom stop sequence was generated, if any.
//
// This value will be a non-null string if one of your custom stop sequences was generated.
type Message_StopSequence struct {
	union json.RawMessage
}

// MessageType Object type.
//
// For Messages, this is always `"message"`.
type MessageType string

// Metadata defines model for Metadata.
type Metadata struct {
	// UserId An external identifier for the user who is associated with the request.
	//
	// This should be a uuid, hash value, or other opaque identifier. Anthropic may use this id to help detect abuse. Do not include any identifying information such as name, email address, or phone number.
	UserId *Metadata_UserId `json:"user_id"`
}

// MetadataUserId0 defines model for .
type MetadataUserId0 = string

// Metadata_UserId An external identifier for the user who is associated with the request.
//
// This should be a uuid, hash value, or other opaque identifier. Anthropic may use this id to help detect abuse. Do not include any identifying information such as name, email address, or phone number.
type Metadata_UserId struct {
	union json.RawMessage
}

// Model The model that will complete your prompt.\n\nSee [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
type Model struct {
	union json.RawMessage
}

// Model0 defines model for .
type Model0 = string

// Model1 defines model for Model.1.
type Model1 string

// NotFoundError defines model for NotFoundError.
type NotFoundError struct {
	Message string            `json:"message"`
	Type    NotFoundErrorType `json:"type"`
}

// NotFoundErrorType defines model for NotFoundError.Type.
type NotFoundErrorType string

// OverloadedError defines model for OverloadedError.
type OverloadedError struct {
	Message string              `json:"message"`
	Type    OverloadedErrorType `json:"type"`
}

// OverloadedErrorType defines model for OverloadedError.Type.
type OverloadedErrorType string

// PermissionError defines model for PermissionError.
type PermissionError struct {
	Message string              `json:"message"`
	Type    PermissionErrorType `json:"type"`
}

// PermissionErrorType defines model for PermissionError.Type.
type PermissionErrorType string

// PromptCachingBetaCreateMessageParams defines model for PromptCachingBetaCreateMessageParams.
type PromptCachingBetaCreateMessageParams struct {
	// MaxTokens The maximum number of tokens to generate before stopping.
	//
	// Note that our models may stop _before_ reaching this maximum. This parameter only specifies the absolute maximum number of tokens to generate.
	//
	// Different models have different maximum values for this parameter.  See [models](https://docs.anthropic.com/en/docs/models-overview) for details.
	MaxTokens int `json:"max_tokens"`

	// Messages Input messages.
	//
	// Our models are trained to operate on alternating `user` and `assistant` conversational turns. When creating a new `Message`, you specify the prior conversational turns with the `messages` parameter, and the model then generates the next `Message` in the conversation. Consecutive `user` or `assistant` turns in your request will be combined into a single turn.
	//
	// Each input message must be an object with a `role` and `content`. You can specify a single `user`-role message, or you can include multiple `user` and `assistant` messages.
	//
	// If the final message uses the `assistant` role, the response content will continue immediately from the content in that message. This can be used to constrain part of the model's response.
	//
	// Example with a single `user` message:
	//
	// ```json
	// [{"role": "user", "content": "Hello, Claude"}]
	// ```
	//
	// Example with multiple conversational turns:
	//
	// ```json
	// [
	//   {"role": "user", "content": "Hello there."},
	//   {"role": "assistant", "content": "Hi, I'm Claude. How can I help you?"},
	//   {"role": "user", "content": "Can you explain LLMs in plain English?"},
	// ]
	// ```
	//
	// Example with a partially-filled response from Claude:
	//
	// ```json
	// [
	//   {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
	//   {"role": "assistant", "content": "The best answer is ("},
	// ]
	// ```
	//
	// Each input message `content` may be either a single `string` or an array of content blocks, where each block has a specific `type`. Using a `string` for `content` is shorthand for an array of one content block of type `"text"`. The following input messages are equivalent:
	//
	// ```json
	// {"role": "user", "content": "Hello, Claude"}
	// ```
	//
	// ```json
	// {"role": "user", "content": [{"type": "text", "text": "Hello, Claude"}]}
	// ```
	//
	// Starting with Claude 3 models, you can also send image content blocks:
	//
	// ```json
	// {"role": "user", "content": [
	//   {
	//     "type": "image",
	//     "source": {
	//       "type": "base64",
	//       "media_type": "image/jpeg",
	//       "data": "/9j/4AAQSkZJRg...",
	//     }
	//   },
	//   {"type": "text", "text": "What is in this image?"}
	// ]}
	// ```
	//
	// We currently support the `base64` source type for images, and the `image/jpeg`, `image/png`, `image/gif`, and `image/webp` media types.
	//
	// See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for more input examples.
	//
	// Note that if you want to include a [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use the top-level `system` parameter — there is no `"system"` role for input messages in the Messages API.
	Messages []PromptCachingBetaInputMessage `json:"messages"`

	// Metadata An object describing metadata about the request.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Model The model that will complete your prompt.\n\nSee [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
	Model Model `json:"model"`

	// StopSequences Custom text sequences that will cause the model to stop generating.
	//
	// Our models will normally stop when they have naturally completed their turn, which will result in a response `stop_reason` of `"end_turn"`.
	//
	// If you want the model to stop generating when it encounters custom strings of text, you can use the `stop_sequences` parameter. If the model encounters one of the custom sequences, the response `stop_reason` value will be `"stop_sequence"` and the response `stop_sequence` value will contain the matched stop sequence.
	StopSequences *[]string `json:"stop_sequences,omitempty"`

	// Stream Whether to incrementally stream the response using server-sent events.
	//
	// See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for details.
	Stream *bool `json:"stream,omitempty"`

	// System System prompt.
	//
	// A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
	System *PromptCachingBetaCreateMessageParams_System `json:"system,omitempty"`

	// Temperature Amount of randomness injected into the response.
	//
	// Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0` for analytical / multiple choice, and closer to `1.0` for creative and generative tasks.
	//
	// Note that even with `temperature` of `0.0`, the results will not be fully deterministic.
	Temperature *float32 `json:"temperature,omitempty"`

	// ToolChoice How the model should use the provided tools. The model can use a specific tool, any available tool, or decide by itself.
	ToolChoice *ToolChoice `json:"tool_choice,omitempty"`

	// Tools Definitions of tools that the model may use.
	//
	// If you include `tools` in your API request, the model may return `tool_use` content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using `tool_result` content blocks.
	//
	// Each tool definition includes:
	//
	// * `name`: Name of the tool.
	// * `description`: Optional, but strongly-recommended description of the tool.
	// * `input_schema`: [JSON schema](https://json-schema.org/) for the tool `input` shape that the model will produce in `tool_use` output content blocks.
	//
	// For example, if you defined `tools` as:
	//
	// ```json
	// [
	//   {
	//     "name": "get_stock_price",
	//     "description": "Get the current stock price for a given ticker symbol.",
	//     "input_schema": {
	//       "type": "object",
	//       "properties": {
	//         "ticker": {
	//           "type": "string",
	//           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
	//         }
	//       },
	//       "required": ["ticker"]
	//     }
	//   }
	// ]
	// ```
	//
	// And then asked the model "What's the S&P 500 at today?", the model might produce `tool_use` content blocks in the response like this:
	//
	// ```json
	// [
	//   {
	//     "type": "tool_use",
	//     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
	//     "name": "get_stock_price",
	//     "input": { "ticker": "^GSPC" }
	//   }
	// ]
	// ```
	//
	// You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an input, and return the following back to the model in a subsequent `user` message:
	//
	// ```json
	// [
	//   {
	//     "type": "tool_result",
	//     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
	//     "content": "259.75 USD"
	//   }
	// ]
	// ```
	//
	// Tools can be used for workflows that include running client-side tools and functions, or more generally whenever you want the model to produce a particular JSON structure of output.
	//
	// See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
	Tools *[]PromptCachingBetaTool `json:"tools,omitempty"`

	// TopK Only sample from the top K options for each subsequent token.
	//
	// Used to remove "long tail" low probability responses. [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
	//
	// Recommended for advanced use cases only. You usually only need to use `temperature`.
	TopK *int `json:"top_k,omitempty"`

	// TopP Use nucleus sampling.
	//
	// In nucleus sampling, we compute the cumulative distribution over all the options for each subsequent token in decreasing probability order and cut it off once it reaches a particular probability specified by `top_p`. You should either alter `temperature` or `top_p`, but not both.
	//
	// Recommended for advanced use cases only. You usually only need to use `temperature`.
	TopP *float32 `json:"top_p,omitempty"`
}

// PromptCachingBetaCreateMessageParamsSystem0 defines model for .
type PromptCachingBetaCreateMessageParamsSystem0 = string

// PromptCachingBetaCreateMessageParamsSystem1 defines model for .
type PromptCachingBetaCreateMessageParamsSystem1 = []PromptCachingBetaRequestTextBlock

// PromptCachingBetaCreateMessageParams_System System prompt.
//
// A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
type PromptCachingBetaCreateMessageParams_System struct {
	union json.RawMessage
}

// PromptCachingBetaInputMessage defines model for PromptCachingBetaInputMessage.
type PromptCachingBetaInputMessage struct {
	Content PromptCachingBetaInputMessage_Content `json:"content"`
	Role    PromptCachingBetaInputMessageRole     `json:"role"`
}

// PromptCachingBetaInputMessageContent0 defines model for .
type PromptCachingBetaInputMessageContent0 = string

// PromptCachingBetaInputMessageContent1 defines model for .
type PromptCachingBetaInputMessageContent1 = []PromptCachingBetaInputMessage_Content_1_Item

// PromptCachingBetaInputMessage_Content_1_Item defines model for PromptCachingBetaInputMessage.Content.1.Item.
type PromptCachingBetaInputMessage_Content_1_Item struct {
	union json.RawMessage
}

// PromptCachingBetaInputMessage_Content defines model for PromptCachingBetaInputMessage.Content.
type PromptCachingBetaInputMessage_Content struct {
	union json.RawMessage
}

// PromptCachingBetaInputMessageRole defines model for PromptCachingBetaInputMessage.Role.
type PromptCachingBetaInputMessageRole string

// PromptCachingBetaMessage defines model for PromptCachingBetaMessage.
type PromptCachingBetaMessage struct {
	// Content Content generated by the model.
	//
	// This is an array of content blocks, each of which has a `type` that determines its shape.
	//
	// Example:
	//
	// ```json
	// [{"type": "text", "text": "Hi, I'm Claude."}]
	// ```
	//
	// If the request input `messages` ended with an `assistant` turn, then the response `content` will continue directly from that last turn. You can use this to constrain the model's output.
	//
	// For example, if the input `messages` were:
	// ```json
	// [
	//   {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
	//   {"role": "assistant", "content": "The best answer is ("}
	// ]
	// ```
	//
	// Then the response `content` might be:
	//
	// ```json
	// [{"type": "text", "text": "B)"}]
	// ```
	Content []ContentBlock `json:"content"`

	// Id Unique object identifier.
	//
	// The format and length of IDs may change over time.
	Id string `json:"id"`

	// Model The model that will complete your prompt.\n\nSee [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
	Model Model `json:"model"`

	// Role Conversational role of the generated message.
	//
	// This will always be `"assistant"`.
	Role PromptCachingBetaMessageRole `json:"role"`

	// StopReason The reason that we stopped.
	//
	// This may be one the following values:
	// * `"end_turn"`: the model reached a natural stopping point
	// * `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
	// * `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
	// * `"tool_use"`: the model invoked one or more tools
	//
	// In non-streaming mode this value is always non-null. In streaming mode, it is null in the `message_start` event and non-null otherwise.
	StopReason *PromptCachingBetaMessage_StopReason `json:"stop_reason"`

	// StopSequence Which custom stop sequence was generated, if any.
	//
	// This value will be a non-null string if one of your custom stop sequences was generated.
	StopSequence *PromptCachingBetaMessage_StopSequence `json:"stop_sequence"`

	// Type Object type.
	//
	// For Messages, this is always `"message"`.
	Type PromptCachingBetaMessageType `json:"type"`

	// Usage Billing and rate-limit usage.
	//
	// Anthropic's API bills and rate-limits by token counts, as tokens represent the underlying cost to our systems.
	//
	// Under the hood, the API transforms requests into a format suitable for the model. The model's output then goes through a parsing stage before becoming an API response. As a result, the token counts in `usage` will not match one-to-one with the exact visible content of an API request or response.
	//
	// For example, `output_tokens` will be non-zero, even for an empty string response from Claude.
	Usage PromptCachingBetaUsage `json:"usage"`
}

// PromptCachingBetaMessageRole Conversational role of the generated message.
//
// This will always be `"assistant"`.
type PromptCachingBetaMessageRole string

// PromptCachingBetaMessageStopReason0 defines model for PromptCachingBetaMessage.StopReason.0.
type PromptCachingBetaMessageStopReason0 string

// PromptCachingBetaMessage_StopReason The reason that we stopped.
//
// This may be one the following values:
// * `"end_turn"`: the model reached a natural stopping point
// * `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
// * `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
// * `"tool_use"`: the model invoked one or more tools
//
// In non-streaming mode this value is always non-null. In streaming mode, it is null in the `message_start` event and non-null otherwise.
type PromptCachingBetaMessage_StopReason struct {
	union json.RawMessage
}

// PromptCachingBetaMessageStopSequence0 defines model for .
type PromptCachingBetaMessageStopSequence0 = string

// PromptCachingBetaMessage_StopSequence Which custom stop sequence was generated, if any.
//
// This value will be a non-null string if one of your custom stop sequences was generated.
type PromptCachingBetaMessage_StopSequence struct {
	union json.RawMessage
}

// PromptCachingBetaMessageType Object type.
//
// For Messages, this is always `"message"`.
type PromptCachingBetaMessageType string

// PromptCachingBetaRequestImageBlock defines model for PromptCachingBetaRequestImageBlock.
type PromptCachingBetaRequestImageBlock struct {
	CacheControl *PromptCachingBetaRequestImageBlock_CacheControl `json:"cache_control"`
	Source       PromptCachingBetaRequestImageBlock_Source        `json:"source"`
	Type         PromptCachingBetaRequestImageBlockType           `json:"type"`
}

// PromptCachingBetaRequestImageBlockCacheControl0 defines model for .
type PromptCachingBetaRequestImageBlockCacheControl0 struct {
	union json.RawMessage
}

// PromptCachingBetaRequestImageBlock_CacheControl defines model for PromptCachingBetaRequestImageBlock.CacheControl.
type PromptCachingBetaRequestImageBlock_CacheControl struct {
	union json.RawMessage
}

// PromptCachingBetaRequestImageBlock_Source defines model for PromptCachingBetaRequestImageBlock.Source.
type PromptCachingBetaRequestImageBlock_Source struct {
	union json.RawMessage
}

// PromptCachingBetaRequestImageBlockType defines model for PromptCachingBetaRequestImageBlock.Type.
type PromptCachingBetaRequestImageBlockType string

// PromptCachingBetaRequestTextBlock defines model for PromptCachingBetaRequestTextBlock.
type PromptCachingBetaRequestTextBlock struct {
	CacheControl *PromptCachingBetaRequestTextBlock_CacheControl `json:"cache_control"`
	Text         string                                          `json:"text"`
	Type         PromptCachingBetaRequestTextBlockType           `json:"type"`
}

// PromptCachingBetaRequestTextBlockCacheControl0 defines model for .
type PromptCachingBetaRequestTextBlockCacheControl0 struct {
	union json.RawMessage
}

// PromptCachingBetaRequestTextBlock_CacheControl defines model for PromptCachingBetaRequestTextBlock.CacheControl.
type PromptCachingBetaRequestTextBlock_CacheControl struct {
	union json.RawMessage
}

// PromptCachingBetaRequestTextBlockType defines model for PromptCachingBetaRequestTextBlock.Type.
type PromptCachingBetaRequestTextBlockType string

// PromptCachingBetaRequestToolResultBlock defines model for PromptCachingBetaRequestToolResultBlock.
type PromptCachingBetaRequestToolResultBlock struct {
	CacheControl *PromptCachingBetaRequestToolResultBlock_CacheControl `json:"cache_control"`
	Content      *PromptCachingBetaRequestToolResultBlock_Content      `json:"content,omitempty"`
	IsError      *bool                                                 `json:"is_error,omitempty"`
	ToolUseId    string                                                `json:"tool_use_id"`
	Type         PromptCachingBetaRequestToolResultBlockType           `json:"type"`
}

// PromptCachingBetaRequestToolResultBlockCacheControl0 defines model for .
type PromptCachingBetaRequestToolResultBlockCacheControl0 struct {
	union json.RawMessage
}

// PromptCachingBetaRequestToolResultBlock_CacheControl defines model for PromptCachingBetaRequestToolResultBlock.CacheControl.
type PromptCachingBetaRequestToolResultBlock_CacheControl struct {
	union json.RawMessage
}

// PromptCachingBetaRequestToolResultBlockContent0 defines model for .
type PromptCachingBetaRequestToolResultBlockContent0 = string

// PromptCachingBetaRequestToolResultBlockContent1 defines model for .
type PromptCachingBetaRequestToolResultBlockContent1 = []PromptCachingBetaRequestToolResultBlock_Content_1_Item

// PromptCachingBetaRequestToolResultBlock_Content_1_Item defines model for PromptCachingBetaRequestToolResultBlock.Content.1.Item.
type PromptCachingBetaRequestToolResultBlock_Content_1_Item struct {
	union json.RawMessage
}

// PromptCachingBetaRequestToolResultBlock_Content defines model for PromptCachingBetaRequestToolResultBlock.Content.
type PromptCachingBetaRequestToolResultBlock_Content struct {
	union json.RawMessage
}

// PromptCachingBetaRequestToolResultBlockType defines model for PromptCachingBetaRequestToolResultBlock.Type.
type PromptCachingBetaRequestToolResultBlockType string

// PromptCachingBetaRequestToolUseBlock defines model for PromptCachingBetaRequestToolUseBlock.
type PromptCachingBetaRequestToolUseBlock struct {
	CacheControl *PromptCachingBetaRequestToolUseBlock_CacheControl `json:"cache_control"`
	Id           string                                             `json:"id"`
	Input        map[string]interface{}                             `json:"input"`
	Name         string                                             `json:"name"`
	Type         PromptCachingBetaRequestToolUseBlockType           `json:"type"`
}

// PromptCachingBetaRequestToolUseBlockCacheControl0 defines model for .
type PromptCachingBetaRequestToolUseBlockCacheControl0 struct {
	union json.RawMessage
}

// PromptCachingBetaRequestToolUseBlock_CacheControl defines model for PromptCachingBetaRequestToolUseBlock.CacheControl.
type PromptCachingBetaRequestToolUseBlock_CacheControl struct {
	union json.RawMessage
}

// PromptCachingBetaRequestToolUseBlockType defines model for PromptCachingBetaRequestToolUseBlock.Type.
type PromptCachingBetaRequestToolUseBlockType string

// PromptCachingBetaTool defines model for PromptCachingBetaTool.
type PromptCachingBetaTool struct {
	CacheControl *PromptCachingBetaTool_CacheControl `json:"cache_control"`

	// Description Description of what this tool does.
	//
	// Tool descriptions should be as detailed as possible. The more information that the model has about what the tool is and how to use it, the better it will perform. You can use natural language descriptions to reinforce important aspects of the tool input JSON schema.
	Description *string `json:"description,omitempty"`

	// InputSchema [JSON schema](https://json-schema.org/) for this tool's input.
	//
	// This defines the shape of the `input` that your tool accepts and that the model will produce.
	InputSchema InputSchema `json:"input_schema"`

	// Name Name of the tool.
	//
	// This is how the tool will be called by the model and in tool_use blocks.
	Name string `json:"name"`
}

// PromptCachingBetaToolCacheControl0 defines model for .
type PromptCachingBetaToolCacheControl0 struct {
	union json.RawMessage
}

// PromptCachingBetaTool_CacheControl defines model for PromptCachingBetaTool.CacheControl.
type PromptCachingBetaTool_CacheControl struct {
	union json.RawMessage
}

// PromptCachingBetaUsage defines model for PromptCachingBetaUsage.
type PromptCachingBetaUsage struct {
	// CacheCreationInputTokens The number of input tokens used to create the cache entry.
	CacheCreationInputTokens *PromptCachingBetaUsage_CacheCreationInputTokens `json:"cache_creation_input_tokens"`

	// CacheReadInputTokens The number of input tokens read from the cache.
	CacheReadInputTokens *PromptCachingBetaUsage_CacheReadInputTokens `json:"cache_read_input_tokens"`

	// InputTokens The number of input tokens which were used.
	InputTokens int `json:"input_tokens"`

	// OutputTokens The number of output tokens which were used.
	OutputTokens int `json:"output_tokens"`
}

// PromptCachingBetaUsageCacheCreationInputTokens0 defines model for .
type PromptCachingBetaUsageCacheCreationInputTokens0 = int

// PromptCachingBetaUsage_CacheCreationInputTokens The number of input tokens used to create the cache entry.
type PromptCachingBetaUsage_CacheCreationInputTokens struct {
	union json.RawMessage
}

// PromptCachingBetaUsageCacheReadInputTokens0 defines model for .
type PromptCachingBetaUsageCacheReadInputTokens0 = int

// PromptCachingBetaUsage_CacheReadInputTokens The number of input tokens read from the cache.
type PromptCachingBetaUsage_CacheReadInputTokens struct {
	union json.RawMessage
}

// RateLimitError defines model for RateLimitError.
type RateLimitError struct {
	Message string             `json:"message"`
	Type    RateLimitErrorType `json:"type"`
}

// RateLimitErrorType defines model for RateLimitError.Type.
type RateLimitErrorType string

// RequestImageBlock defines model for RequestImageBlock.
type RequestImageBlock struct {
	Source RequestImageBlock_Source `json:"source"`
	Type   RequestImageBlockType    `json:"type"`
}

// RequestImageBlock_Source defines model for RequestImageBlock.Source.
type RequestImageBlock_Source struct {
	union json.RawMessage
}

// RequestImageBlockType defines model for RequestImageBlock.Type.
type RequestImageBlockType string

// RequestTextBlock defines model for RequestTextBlock.
type RequestTextBlock struct {
	Text string               `json:"text"`
	Type RequestTextBlockType `json:"type"`
}

// RequestTextBlockType defines model for RequestTextBlock.Type.
type RequestTextBlockType string

// RequestToolResultBlock defines model for RequestToolResultBlock.
type RequestToolResultBlock struct {
	Content   *RequestToolResultBlock_Content `json:"content,omitempty"`
	IsError   *bool                           `json:"is_error,omitempty"`
	ToolUseId string                          `json:"tool_use_id"`
	Type      RequestToolResultBlockType      `json:"type"`
}

// RequestToolResultBlockContent0 defines model for .
type RequestToolResultBlockContent0 = string

// RequestToolResultBlockContent1 defines model for .
type RequestToolResultBlockContent1 = []RequestToolResultBlock_Content_1_Item

// RequestToolResultBlock_Content_1_Item defines model for RequestToolResultBlock.Content.1.Item.
type RequestToolResultBlock_Content_1_Item struct {
	union json.RawMessage
}

// RequestToolResultBlock_Content defines model for RequestToolResultBlock.Content.
type RequestToolResultBlock_Content struct {
	union json.RawMessage
}

// RequestToolResultBlockType defines model for RequestToolResultBlock.Type.
type RequestToolResultBlockType string

// RequestToolUseBlock defines model for RequestToolUseBlock.
type RequestToolUseBlock struct {
	Id    string                  `json:"id"`
	Input map[string]interface{}  `json:"input"`
	Name  string                  `json:"name"`
	Type  RequestToolUseBlockType `json:"type"`
}

// RequestToolUseBlockType defines model for RequestToolUseBlock.Type.
type RequestToolUseBlockType string

// ResponseTextBlock defines model for ResponseTextBlock.
type ResponseTextBlock struct {
	Text string                `json:"text"`
	Type ResponseTextBlockType `json:"type"`
}

// ResponseTextBlockType defines model for ResponseTextBlock.Type.
type ResponseTextBlockType string

// ResponseToolUseBlock defines model for ResponseToolUseBlock.
type ResponseToolUseBlock struct {
	Id    string                   `json:"id"`
	Input map[string]interface{}   `json:"input"`
	Name  string                   `json:"name"`
	Type  ResponseToolUseBlockType `json:"type"`
}

// ResponseToolUseBlockType defines model for ResponseToolUseBlock.Type.
type ResponseToolUseBlockType string

// Tool defines model for Tool.
type Tool struct {
	// Description Description of what this tool does.
	//
	// Tool descriptions should be as detailed as possible. The more information that the model has about what the tool is and how to use it, the better it will perform. You can use natural language descriptions to reinforce important aspects of the tool input JSON schema.
	Description *string `json:"description,omitempty"`

	// InputSchema [JSON schema](https://json-schema.org/) for this tool's input.
	//
	// This defines the shape of the `input` that your tool accepts and that the model will produce.
	InputSchema InputSchema `json:"input_schema"`

	// Name Name of the tool.
	//
	// This is how the tool will be called by the model and in tool_use blocks.
	Name string `json:"name"`
}

// ToolChoice How the model should use the provided tools. The model can use a specific tool, any available tool, or decide by itself.
type ToolChoice struct {
	union json.RawMessage
}

// ToolChoiceAny The model will use any available tools.
type ToolChoiceAny struct {
	// DisableParallelToolUse Whether to disable parallel tool use.
	//
	// Defaults to `false`. If set to `true`, the model will output exactly one tool use.
	DisableParallelToolUse *bool             `json:"disable_parallel_tool_use,omitempty"`
	Type                   ToolChoiceAnyType `json:"type"`
}

// ToolChoiceAnyType defines model for ToolChoiceAny.Type.
type ToolChoiceAnyType string

// ToolChoiceAuto The model will automatically decide whether to use tools.
type ToolChoiceAuto struct {
	// DisableParallelToolUse Whether to disable parallel tool use.
	//
	// Defaults to `false`. If set to `true`, the model will output at most one tool use.
	DisableParallelToolUse *bool              `json:"disable_parallel_tool_use,omitempty"`
	Type                   ToolChoiceAutoType `json:"type"`
}

// ToolChoiceAutoType defines model for ToolChoiceAuto.Type.
type ToolChoiceAutoType string

// ToolChoiceTool The model will use the specified tool with `tool_choice.name`.
type ToolChoiceTool struct {
	// DisableParallelToolUse Whether to disable parallel tool use.
	//
	// Defaults to `false`. If set to `true`, the model will output exactly one tool use.
	DisableParallelToolUse *bool `json:"disable_parallel_tool_use,omitempty"`

	// Name The name of the tool to use.
	Name string             `json:"name"`
	Type ToolChoiceToolType `json:"type"`
}

// ToolChoiceToolType defines model for ToolChoiceTool.Type.
type ToolChoiceToolType string

// Usage defines model for Usage.
type Usage struct {
	// InputTokens The number of input tokens which were used.
	InputTokens int `json:"input_tokens"`

	// OutputTokens The number of output tokens which were used.
	OutputTokens int `json:"output_tokens"`
}

// CompletePostParams defines parameters for CompletePost.
type CompletePostParams struct {
	// AnthropicVersion The version of the Anthropic API you want to use.
	//
	// Read more about versioning and our version history [here](https://docs.anthropic.com/en/api/versioning).
	AnthropicVersion *string `json:"anthropic-version,omitempty"`

	// XApiKey Your unique API key for authentication.
	//
	// This key is required in the header of all API requests, to authenticate your account and access Anthropic's services. Get your API key through the [Console](https://console.anthropic.com/settings/keys). Each key is scoped to a Workspace.
	XApiKey *string `json:"x-api-key,omitempty"`
}

// MessagesPostParams defines parameters for MessagesPost.
type MessagesPostParams struct {
	// AnthropicVersion The version of the Anthropic API you want to use.
	//
	// Read more about versioning and our version history [here](https://docs.anthropic.com/en/api/versioning).
	AnthropicVersion *string `json:"anthropic-version,omitempty"`

	// XApiKey Your unique API key for authentication.
	//
	// This key is required in the header of all API requests, to authenticate your account and access Anthropic's services. Get your API key through the [Console](https://console.anthropic.com/settings/keys). Each key is scoped to a Workspace.
	XApiKey *string `json:"x-api-key,omitempty"`
}

// BetaMessageBatchesListParams defines parameters for BetaMessageBatchesList.
type BetaMessageBatchesListParams struct {
	// BeforeId ID of the object to use as a cursor for pagination. When provided, returns the page of results immediately before this object.
	BeforeId *string `form:"before_id,omitempty" json:"before_id,omitempty"`

	// AfterId ID of the object to use as a cursor for pagination. When provided, returns the page of results immediately after this object.
	AfterId *string `form:"after_id,omitempty" json:"after_id,omitempty"`

	// Limit Number of items to return per page.
	//
	// Defaults to `20`. Ranges from `1` to `100`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// AnthropicBeta Optional header to specify the beta version(s) you want to use.
	//
	// To use multiple betas, use a comma separated list like `beta1,beta2` or specify the header multiple times for each beta.
	AnthropicBeta *string `json:"anthropic-beta,omitempty"`

	// AnthropicVersion The version of the Anthropic API you want to use.
	//
	// Read more about versioning and our version history [here](https://docs.anthropic.com/en/api/versioning).
	AnthropicVersion *string `json:"anthropic-version,omitempty"`

	// XApiKey Your unique API key for authentication.
	//
	// This key is required in the header of all API requests, to authenticate your account and access Anthropic's services. Get your API key through the [Console](https://console.anthropic.com/settings/keys). Each key is scoped to a Workspace.
	XApiKey *string `json:"x-api-key,omitempty"`
}

// BetaMessageBatchesPostParams defines parameters for BetaMessageBatchesPost.
type BetaMessageBatchesPostParams struct {
	// AnthropicBeta Optional header to specify the beta version(s) you want to use.
	//
	// To use multiple betas, use a comma separated list like `beta1,beta2` or specify the header multiple times for each beta.
	AnthropicBeta *string `json:"anthropic-beta,omitempty"`

	// AnthropicVersion The version of the Anthropic API you want to use.
	//
	// Read more about versioning and our version history [here](https://docs.anthropic.com/en/api/versioning).
	AnthropicVersion *string `json:"anthropic-version,omitempty"`

	// XApiKey Your unique API key for authentication.
	//
	// This key is required in the header of all API requests, to authenticate your account and access Anthropic's services. Get your API key through the [Console](https://console.anthropic.com/settings/keys). Each key is scoped to a Workspace.
	XApiKey *string `json:"x-api-key,omitempty"`
}

// BetaMessageBatchesRetrieveParams defines parameters for BetaMessageBatchesRetrieve.
type BetaMessageBatchesRetrieveParams struct {
	// AnthropicBeta Optional header to specify the beta version(s) you want to use.
	//
	// To use multiple betas, use a comma separated list like `beta1,beta2` or specify the header multiple times for each beta.
	AnthropicBeta *string `json:"anthropic-beta,omitempty"`

	// AnthropicVersion The version of the Anthropic API you want to use.
	//
	// Read more about versioning and our version history [here](https://docs.anthropic.com/en/api/versioning).
	AnthropicVersion *string `json:"anthropic-version,omitempty"`

	// XApiKey Your unique API key for authentication.
	//
	// This key is required in the header of all API requests, to authenticate your account and access Anthropic's services. Get your API key through the [Console](https://console.anthropic.com/settings/keys). Each key is scoped to a Workspace.
	XApiKey *string `json:"x-api-key,omitempty"`
}

// BetaMessageBatchesCancelParams defines parameters for BetaMessageBatchesCancel.
type BetaMessageBatchesCancelParams struct {
	// AnthropicBeta Optional header to specify the beta version(s) you want to use.
	//
	// To use multiple betas, use a comma separated list like `beta1,beta2` or specify the header multiple times for each beta.
	AnthropicBeta *string `json:"anthropic-beta,omitempty"`

	// AnthropicVersion The version of the Anthropic API you want to use.
	//
	// Read more about versioning and our version history [here](https://docs.anthropic.com/en/api/versioning).
	AnthropicVersion *string `json:"anthropic-version,omitempty"`

	// XApiKey Your unique API key for authentication.
	//
	// This key is required in the header of all API requests, to authenticate your account and access Anthropic's services. Get your API key through the [Console](https://console.anthropic.com/settings/keys). Each key is scoped to a Workspace.
	XApiKey *string `json:"x-api-key,omitempty"`
}

// BetaMessageBatchesResultsParams defines parameters for BetaMessageBatchesResults.
type BetaMessageBatchesResultsParams struct {
	// AnthropicBeta Optional header to specify the beta version(s) you want to use.
	//
	// To use multiple betas, use a comma separated list like `beta1,beta2` or specify the header multiple times for each beta.
	AnthropicBeta *string `json:"anthropic-beta,omitempty"`

	// AnthropicVersion The version of the Anthropic API you want to use.
	//
	// Read more about versioning and our version history [here](https://docs.anthropic.com/en/api/versioning).
	AnthropicVersion *string `json:"anthropic-version,omitempty"`

	// XApiKey Your unique API key for authentication.
	//
	// This key is required in the header of all API requests, to authenticate your account and access Anthropic's services. Get your API key through the [Console](https://console.anthropic.com/settings/keys). Each key is scoped to a Workspace.
	XApiKey *string `json:"x-api-key,omitempty"`
}

// BetaMessagesCountTokensPostParams defines parameters for BetaMessagesCountTokensPost.
type BetaMessagesCountTokensPostParams struct {
	// AnthropicBeta Optional header to specify the beta version(s) you want to use.
	//
	// To use multiple betas, use a comma separated list like `beta1,beta2` or specify the header multiple times for each beta.
	AnthropicBeta *string `json:"anthropic-beta,omitempty"`

	// AnthropicVersion The version of the Anthropic API you want to use.
	//
	// Read more about versioning and our version history [here](https://docs.anthropic.com/en/api/versioning).
	AnthropicVersion *string `json:"anthropic-version,omitempty"`

	// XApiKey Your unique API key for authentication.
	//
	// This key is required in the header of all API requests, to authenticate your account and access Anthropic's services. Get your API key through the [Console](https://console.anthropic.com/settings/keys). Each key is scoped to a Workspace.
	XApiKey *string `json:"x-api-key,omitempty"`
}

// PromptCachingBetaMessagesPostParams defines parameters for PromptCachingBetaMessagesPost.
type PromptCachingBetaMessagesPostParams struct {
	// AnthropicBeta Optional header to specify the beta version(s) you want to use.
	//
	// To use multiple betas, use a comma separated list like `beta1,beta2` or specify the header multiple times for each beta.
	AnthropicBeta *string `json:"anthropic-beta,omitempty"`

	// AnthropicVersion The version of the Anthropic API you want to use.
	//
	// Read more about versioning and our version history [here](https://docs.anthropic.com/en/api/versioning).
	AnthropicVersion *string `json:"anthropic-version,omitempty"`

	// XApiKey Your unique API key for authentication.
	//
	// This key is required in the header of all API requests, to authenticate your account and access Anthropic's services. Get your API key through the [Console](https://console.anthropic.com/settings/keys). Each key is scoped to a Workspace.
	XApiKey *string `json:"x-api-key,omitempty"`
}

// CompletePostJSONRequestBody defines body for CompletePost for application/json ContentType.
type CompletePostJSONRequestBody = CompletionRequest

// MessagesPostJSONRequestBody defines body for MessagesPost for application/json ContentType.
type MessagesPostJSONRequestBody = CreateMessageParams

// BetaMessageBatchesPostJSONRequestBody defines body for BetaMessageBatchesPost for application/json ContentType.
type BetaMessageBatchesPostJSONRequestBody = BetaCreateMessageBatchParams

// BetaMessagesCountTokensPostJSONRequestBody defines body for BetaMessagesCountTokensPost for application/json ContentType.
type BetaMessagesCountTokensPostJSONRequestBody = BetaCountMessageTokensParams

// PromptCachingBetaMessagesPostJSONRequestBody defines body for PromptCachingBetaMessagesPost for application/json ContentType.
type PromptCachingBetaMessagesPostJSONRequestBody = PromptCachingBetaCreateMessageParams

// Getter for additional properties for BetaInputSchema. Returns the specified
// element and whether it was found
func (a BetaInputSchema) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for BetaInputSchema
func (a *BetaInputSchema) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for BetaInputSchema to handle AdditionalProperties
func (a *BetaInputSchema) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["properties"]; found {
		err = json.Unmarshal(raw, &a.Properties)
		if err != nil {
			return fmt.Errorf("error reading 'properties': %w", err)
		}
		delete(object, "properties")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for BetaInputSchema to handle AdditionalProperties
func (a BetaInputSchema) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Properties != nil {
		object["properties"], err = json.Marshal(a.Properties)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'properties': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for InputSchema. Returns the specified
// element and whether it was found
func (a InputSchema) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for InputSchema
func (a *InputSchema) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for InputSchema to handle AdditionalProperties
func (a *InputSchema) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["properties"]; found {
		err = json.Unmarshal(raw, &a.Properties)
		if err != nil {
			return fmt.Errorf("error reading 'properties': %w", err)
		}
		delete(object, "properties")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for InputSchema to handle AdditionalProperties
func (a InputSchema) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Properties != nil {
		object["properties"], err = json.Marshal(a.Properties)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'properties': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsBetaCacheControlEphemeral returns the union data inside the BetaBashTool20241022CacheControl0 as a BetaCacheControlEphemeral
func (t BetaBashTool20241022CacheControl0) AsBetaCacheControlEphemeral() (BetaCacheControlEphemeral, error) {
	var body BetaCacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCacheControlEphemeral overwrites any union data inside the BetaBashTool20241022CacheControl0 as the provided BetaCacheControlEphemeral
func (t *BetaBashTool20241022CacheControl0) FromBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCacheControlEphemeral performs a merge with any union data inside the BetaBashTool20241022CacheControl0, using the provided BetaCacheControlEphemeral
func (t *BetaBashTool20241022CacheControl0) MergeBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaBashTool20241022CacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaBashTool20241022CacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsBetaCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaBashTool20241022CacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaBashTool20241022CacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaBashTool20241022CacheControl0 returns the union data inside the BetaBashTool20241022_CacheControl as a BetaBashTool20241022CacheControl0
func (t BetaBashTool20241022_CacheControl) AsBetaBashTool20241022CacheControl0() (BetaBashTool20241022CacheControl0, error) {
	var body BetaBashTool20241022CacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaBashTool20241022CacheControl0 overwrites any union data inside the BetaBashTool20241022_CacheControl as the provided BetaBashTool20241022CacheControl0
func (t *BetaBashTool20241022_CacheControl) FromBetaBashTool20241022CacheControl0(v BetaBashTool20241022CacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaBashTool20241022CacheControl0 performs a merge with any union data inside the BetaBashTool20241022_CacheControl, using the provided BetaBashTool20241022CacheControl0
func (t *BetaBashTool20241022_CacheControl) MergeBetaBashTool20241022CacheControl0(v BetaBashTool20241022CacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaBashTool20241022_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaBashTool20241022_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaCacheControlEphemeral returns the union data inside the BetaComputerUseTool20241022CacheControl0 as a BetaCacheControlEphemeral
func (t BetaComputerUseTool20241022CacheControl0) AsBetaCacheControlEphemeral() (BetaCacheControlEphemeral, error) {
	var body BetaCacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCacheControlEphemeral overwrites any union data inside the BetaComputerUseTool20241022CacheControl0 as the provided BetaCacheControlEphemeral
func (t *BetaComputerUseTool20241022CacheControl0) FromBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCacheControlEphemeral performs a merge with any union data inside the BetaComputerUseTool20241022CacheControl0, using the provided BetaCacheControlEphemeral
func (t *BetaComputerUseTool20241022CacheControl0) MergeBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaComputerUseTool20241022CacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaComputerUseTool20241022CacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsBetaCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaComputerUseTool20241022CacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaComputerUseTool20241022CacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaComputerUseTool20241022CacheControl0 returns the union data inside the BetaComputerUseTool20241022_CacheControl as a BetaComputerUseTool20241022CacheControl0
func (t BetaComputerUseTool20241022_CacheControl) AsBetaComputerUseTool20241022CacheControl0() (BetaComputerUseTool20241022CacheControl0, error) {
	var body BetaComputerUseTool20241022CacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaComputerUseTool20241022CacheControl0 overwrites any union data inside the BetaComputerUseTool20241022_CacheControl as the provided BetaComputerUseTool20241022CacheControl0
func (t *BetaComputerUseTool20241022_CacheControl) FromBetaComputerUseTool20241022CacheControl0(v BetaComputerUseTool20241022CacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaComputerUseTool20241022CacheControl0 performs a merge with any union data inside the BetaComputerUseTool20241022_CacheControl, using the provided BetaComputerUseTool20241022CacheControl0
func (t *BetaComputerUseTool20241022_CacheControl) MergeBetaComputerUseTool20241022CacheControl0(v BetaComputerUseTool20241022CacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaComputerUseTool20241022_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaComputerUseTool20241022_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaComputerUseTool20241022DisplayNumber0 returns the union data inside the BetaComputerUseTool20241022_DisplayNumber as a BetaComputerUseTool20241022DisplayNumber0
func (t BetaComputerUseTool20241022_DisplayNumber) AsBetaComputerUseTool20241022DisplayNumber0() (BetaComputerUseTool20241022DisplayNumber0, error) {
	var body BetaComputerUseTool20241022DisplayNumber0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaComputerUseTool20241022DisplayNumber0 overwrites any union data inside the BetaComputerUseTool20241022_DisplayNumber as the provided BetaComputerUseTool20241022DisplayNumber0
func (t *BetaComputerUseTool20241022_DisplayNumber) FromBetaComputerUseTool20241022DisplayNumber0(v BetaComputerUseTool20241022DisplayNumber0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaComputerUseTool20241022DisplayNumber0 performs a merge with any union data inside the BetaComputerUseTool20241022_DisplayNumber, using the provided BetaComputerUseTool20241022DisplayNumber0
func (t *BetaComputerUseTool20241022_DisplayNumber) MergeBetaComputerUseTool20241022DisplayNumber0(v BetaComputerUseTool20241022DisplayNumber0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaComputerUseTool20241022_DisplayNumber) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaComputerUseTool20241022_DisplayNumber) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaCountMessageTokensParamsSystem0 returns the union data inside the BetaCountMessageTokensParams_System as a BetaCountMessageTokensParamsSystem0
func (t BetaCountMessageTokensParams_System) AsBetaCountMessageTokensParamsSystem0() (BetaCountMessageTokensParamsSystem0, error) {
	var body BetaCountMessageTokensParamsSystem0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCountMessageTokensParamsSystem0 overwrites any union data inside the BetaCountMessageTokensParams_System as the provided BetaCountMessageTokensParamsSystem0
func (t *BetaCountMessageTokensParams_System) FromBetaCountMessageTokensParamsSystem0(v BetaCountMessageTokensParamsSystem0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCountMessageTokensParamsSystem0 performs a merge with any union data inside the BetaCountMessageTokensParams_System, using the provided BetaCountMessageTokensParamsSystem0
func (t *BetaCountMessageTokensParams_System) MergeBetaCountMessageTokensParamsSystem0(v BetaCountMessageTokensParamsSystem0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaCountMessageTokensParamsSystem1 returns the union data inside the BetaCountMessageTokensParams_System as a BetaCountMessageTokensParamsSystem1
func (t BetaCountMessageTokensParams_System) AsBetaCountMessageTokensParamsSystem1() (BetaCountMessageTokensParamsSystem1, error) {
	var body BetaCountMessageTokensParamsSystem1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCountMessageTokensParamsSystem1 overwrites any union data inside the BetaCountMessageTokensParams_System as the provided BetaCountMessageTokensParamsSystem1
func (t *BetaCountMessageTokensParams_System) FromBetaCountMessageTokensParamsSystem1(v BetaCountMessageTokensParamsSystem1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCountMessageTokensParamsSystem1 performs a merge with any union data inside the BetaCountMessageTokensParams_System, using the provided BetaCountMessageTokensParamsSystem1
func (t *BetaCountMessageTokensParams_System) MergeBetaCountMessageTokensParamsSystem1(v BetaCountMessageTokensParamsSystem1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaCountMessageTokensParams_System) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaCountMessageTokensParams_System) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaTool returns the union data inside the BetaCountMessageTokensParams_Tools_Item as a BetaTool
func (t BetaCountMessageTokensParams_Tools_Item) AsBetaTool() (BetaTool, error) {
	var body BetaTool
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaTool overwrites any union data inside the BetaCountMessageTokensParams_Tools_Item as the provided BetaTool
func (t *BetaCountMessageTokensParams_Tools_Item) FromBetaTool(v BetaTool) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaTool performs a merge with any union data inside the BetaCountMessageTokensParams_Tools_Item, using the provided BetaTool
func (t *BetaCountMessageTokensParams_Tools_Item) MergeBetaTool(v BetaTool) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaComputerUseTool20241022 returns the union data inside the BetaCountMessageTokensParams_Tools_Item as a BetaComputerUseTool20241022
func (t BetaCountMessageTokensParams_Tools_Item) AsBetaComputerUseTool20241022() (BetaComputerUseTool20241022, error) {
	var body BetaComputerUseTool20241022
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaComputerUseTool20241022 overwrites any union data inside the BetaCountMessageTokensParams_Tools_Item as the provided BetaComputerUseTool20241022
func (t *BetaCountMessageTokensParams_Tools_Item) FromBetaComputerUseTool20241022(v BetaComputerUseTool20241022) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaComputerUseTool20241022 performs a merge with any union data inside the BetaCountMessageTokensParams_Tools_Item, using the provided BetaComputerUseTool20241022
func (t *BetaCountMessageTokensParams_Tools_Item) MergeBetaComputerUseTool20241022(v BetaComputerUseTool20241022) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaBashTool20241022 returns the union data inside the BetaCountMessageTokensParams_Tools_Item as a BetaBashTool20241022
func (t BetaCountMessageTokensParams_Tools_Item) AsBetaBashTool20241022() (BetaBashTool20241022, error) {
	var body BetaBashTool20241022
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaBashTool20241022 overwrites any union data inside the BetaCountMessageTokensParams_Tools_Item as the provided BetaBashTool20241022
func (t *BetaCountMessageTokensParams_Tools_Item) FromBetaBashTool20241022(v BetaBashTool20241022) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaBashTool20241022 performs a merge with any union data inside the BetaCountMessageTokensParams_Tools_Item, using the provided BetaBashTool20241022
func (t *BetaCountMessageTokensParams_Tools_Item) MergeBetaBashTool20241022(v BetaBashTool20241022) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaTextEditor20241022 returns the union data inside the BetaCountMessageTokensParams_Tools_Item as a BetaTextEditor20241022
func (t BetaCountMessageTokensParams_Tools_Item) AsBetaTextEditor20241022() (BetaTextEditor20241022, error) {
	var body BetaTextEditor20241022
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaTextEditor20241022 overwrites any union data inside the BetaCountMessageTokensParams_Tools_Item as the provided BetaTextEditor20241022
func (t *BetaCountMessageTokensParams_Tools_Item) FromBetaTextEditor20241022(v BetaTextEditor20241022) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaTextEditor20241022 performs a merge with any union data inside the BetaCountMessageTokensParams_Tools_Item, using the provided BetaTextEditor20241022
func (t *BetaCountMessageTokensParams_Tools_Item) MergeBetaTextEditor20241022(v BetaTextEditor20241022) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaCountMessageTokensParams_Tools_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaCountMessageTokensParams_Tools_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaCreateMessageParamsSystem0 returns the union data inside the BetaCreateMessageParams_System as a BetaCreateMessageParamsSystem0
func (t BetaCreateMessageParams_System) AsBetaCreateMessageParamsSystem0() (BetaCreateMessageParamsSystem0, error) {
	var body BetaCreateMessageParamsSystem0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCreateMessageParamsSystem0 overwrites any union data inside the BetaCreateMessageParams_System as the provided BetaCreateMessageParamsSystem0
func (t *BetaCreateMessageParams_System) FromBetaCreateMessageParamsSystem0(v BetaCreateMessageParamsSystem0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCreateMessageParamsSystem0 performs a merge with any union data inside the BetaCreateMessageParams_System, using the provided BetaCreateMessageParamsSystem0
func (t *BetaCreateMessageParams_System) MergeBetaCreateMessageParamsSystem0(v BetaCreateMessageParamsSystem0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaCreateMessageParamsSystem1 returns the union data inside the BetaCreateMessageParams_System as a BetaCreateMessageParamsSystem1
func (t BetaCreateMessageParams_System) AsBetaCreateMessageParamsSystem1() (BetaCreateMessageParamsSystem1, error) {
	var body BetaCreateMessageParamsSystem1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCreateMessageParamsSystem1 overwrites any union data inside the BetaCreateMessageParams_System as the provided BetaCreateMessageParamsSystem1
func (t *BetaCreateMessageParams_System) FromBetaCreateMessageParamsSystem1(v BetaCreateMessageParamsSystem1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCreateMessageParamsSystem1 performs a merge with any union data inside the BetaCreateMessageParams_System, using the provided BetaCreateMessageParamsSystem1
func (t *BetaCreateMessageParams_System) MergeBetaCreateMessageParamsSystem1(v BetaCreateMessageParamsSystem1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaCreateMessageParams_System) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaCreateMessageParams_System) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaTool returns the union data inside the BetaCreateMessageParams_Tools_Item as a BetaTool
func (t BetaCreateMessageParams_Tools_Item) AsBetaTool() (BetaTool, error) {
	var body BetaTool
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaTool overwrites any union data inside the BetaCreateMessageParams_Tools_Item as the provided BetaTool
func (t *BetaCreateMessageParams_Tools_Item) FromBetaTool(v BetaTool) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaTool performs a merge with any union data inside the BetaCreateMessageParams_Tools_Item, using the provided BetaTool
func (t *BetaCreateMessageParams_Tools_Item) MergeBetaTool(v BetaTool) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaComputerUseTool20241022 returns the union data inside the BetaCreateMessageParams_Tools_Item as a BetaComputerUseTool20241022
func (t BetaCreateMessageParams_Tools_Item) AsBetaComputerUseTool20241022() (BetaComputerUseTool20241022, error) {
	var body BetaComputerUseTool20241022
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaComputerUseTool20241022 overwrites any union data inside the BetaCreateMessageParams_Tools_Item as the provided BetaComputerUseTool20241022
func (t *BetaCreateMessageParams_Tools_Item) FromBetaComputerUseTool20241022(v BetaComputerUseTool20241022) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaComputerUseTool20241022 performs a merge with any union data inside the BetaCreateMessageParams_Tools_Item, using the provided BetaComputerUseTool20241022
func (t *BetaCreateMessageParams_Tools_Item) MergeBetaComputerUseTool20241022(v BetaComputerUseTool20241022) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaBashTool20241022 returns the union data inside the BetaCreateMessageParams_Tools_Item as a BetaBashTool20241022
func (t BetaCreateMessageParams_Tools_Item) AsBetaBashTool20241022() (BetaBashTool20241022, error) {
	var body BetaBashTool20241022
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaBashTool20241022 overwrites any union data inside the BetaCreateMessageParams_Tools_Item as the provided BetaBashTool20241022
func (t *BetaCreateMessageParams_Tools_Item) FromBetaBashTool20241022(v BetaBashTool20241022) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaBashTool20241022 performs a merge with any union data inside the BetaCreateMessageParams_Tools_Item, using the provided BetaBashTool20241022
func (t *BetaCreateMessageParams_Tools_Item) MergeBetaBashTool20241022(v BetaBashTool20241022) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaTextEditor20241022 returns the union data inside the BetaCreateMessageParams_Tools_Item as a BetaTextEditor20241022
func (t BetaCreateMessageParams_Tools_Item) AsBetaTextEditor20241022() (BetaTextEditor20241022, error) {
	var body BetaTextEditor20241022
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaTextEditor20241022 overwrites any union data inside the BetaCreateMessageParams_Tools_Item as the provided BetaTextEditor20241022
func (t *BetaCreateMessageParams_Tools_Item) FromBetaTextEditor20241022(v BetaTextEditor20241022) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaTextEditor20241022 performs a merge with any union data inside the BetaCreateMessageParams_Tools_Item, using the provided BetaTextEditor20241022
func (t *BetaCreateMessageParams_Tools_Item) MergeBetaTextEditor20241022(v BetaTextEditor20241022) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaCreateMessageParams_Tools_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaCreateMessageParams_Tools_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaInvalidRequestError returns the union data inside the BetaErrorResponse_Error as a BetaInvalidRequestError
func (t BetaErrorResponse_Error) AsBetaInvalidRequestError() (BetaInvalidRequestError, error) {
	var body BetaInvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaInvalidRequestError overwrites any union data inside the BetaErrorResponse_Error as the provided BetaInvalidRequestError
func (t *BetaErrorResponse_Error) FromBetaInvalidRequestError(v BetaInvalidRequestError) error {
	v.Type = "invalid_request_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaInvalidRequestError performs a merge with any union data inside the BetaErrorResponse_Error, using the provided BetaInvalidRequestError
func (t *BetaErrorResponse_Error) MergeBetaInvalidRequestError(v BetaInvalidRequestError) error {
	v.Type = "invalid_request_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaAuthenticationError returns the union data inside the BetaErrorResponse_Error as a BetaAuthenticationError
func (t BetaErrorResponse_Error) AsBetaAuthenticationError() (BetaAuthenticationError, error) {
	var body BetaAuthenticationError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaAuthenticationError overwrites any union data inside the BetaErrorResponse_Error as the provided BetaAuthenticationError
func (t *BetaErrorResponse_Error) FromBetaAuthenticationError(v BetaAuthenticationError) error {
	v.Type = "authentication_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaAuthenticationError performs a merge with any union data inside the BetaErrorResponse_Error, using the provided BetaAuthenticationError
func (t *BetaErrorResponse_Error) MergeBetaAuthenticationError(v BetaAuthenticationError) error {
	v.Type = "authentication_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaPermissionError returns the union data inside the BetaErrorResponse_Error as a BetaPermissionError
func (t BetaErrorResponse_Error) AsBetaPermissionError() (BetaPermissionError, error) {
	var body BetaPermissionError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaPermissionError overwrites any union data inside the BetaErrorResponse_Error as the provided BetaPermissionError
func (t *BetaErrorResponse_Error) FromBetaPermissionError(v BetaPermissionError) error {
	v.Type = "permission_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaPermissionError performs a merge with any union data inside the BetaErrorResponse_Error, using the provided BetaPermissionError
func (t *BetaErrorResponse_Error) MergeBetaPermissionError(v BetaPermissionError) error {
	v.Type = "permission_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaNotFoundError returns the union data inside the BetaErrorResponse_Error as a BetaNotFoundError
func (t BetaErrorResponse_Error) AsBetaNotFoundError() (BetaNotFoundError, error) {
	var body BetaNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaNotFoundError overwrites any union data inside the BetaErrorResponse_Error as the provided BetaNotFoundError
func (t *BetaErrorResponse_Error) FromBetaNotFoundError(v BetaNotFoundError) error {
	v.Type = "not_found_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaNotFoundError performs a merge with any union data inside the BetaErrorResponse_Error, using the provided BetaNotFoundError
func (t *BetaErrorResponse_Error) MergeBetaNotFoundError(v BetaNotFoundError) error {
	v.Type = "not_found_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaRateLimitError returns the union data inside the BetaErrorResponse_Error as a BetaRateLimitError
func (t BetaErrorResponse_Error) AsBetaRateLimitError() (BetaRateLimitError, error) {
	var body BetaRateLimitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRateLimitError overwrites any union data inside the BetaErrorResponse_Error as the provided BetaRateLimitError
func (t *BetaErrorResponse_Error) FromBetaRateLimitError(v BetaRateLimitError) error {
	v.Type = "rate_limit_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRateLimitError performs a merge with any union data inside the BetaErrorResponse_Error, using the provided BetaRateLimitError
func (t *BetaErrorResponse_Error) MergeBetaRateLimitError(v BetaRateLimitError) error {
	v.Type = "rate_limit_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaAPIError returns the union data inside the BetaErrorResponse_Error as a BetaAPIError
func (t BetaErrorResponse_Error) AsBetaAPIError() (BetaAPIError, error) {
	var body BetaAPIError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaAPIError overwrites any union data inside the BetaErrorResponse_Error as the provided BetaAPIError
func (t *BetaErrorResponse_Error) FromBetaAPIError(v BetaAPIError) error {
	v.Type = "api_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaAPIError performs a merge with any union data inside the BetaErrorResponse_Error, using the provided BetaAPIError
func (t *BetaErrorResponse_Error) MergeBetaAPIError(v BetaAPIError) error {
	v.Type = "api_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaOverloadedError returns the union data inside the BetaErrorResponse_Error as a BetaOverloadedError
func (t BetaErrorResponse_Error) AsBetaOverloadedError() (BetaOverloadedError, error) {
	var body BetaOverloadedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaOverloadedError overwrites any union data inside the BetaErrorResponse_Error as the provided BetaOverloadedError
func (t *BetaErrorResponse_Error) FromBetaOverloadedError(v BetaOverloadedError) error {
	v.Type = "overloaded_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaOverloadedError performs a merge with any union data inside the BetaErrorResponse_Error, using the provided BetaOverloadedError
func (t *BetaErrorResponse_Error) MergeBetaOverloadedError(v BetaOverloadedError) error {
	v.Type = "overloaded_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaErrorResponse_Error) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaErrorResponse_Error) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "api_error":
		return t.AsBetaAPIError()
	case "authentication_error":
		return t.AsBetaAuthenticationError()
	case "invalid_request_error":
		return t.AsBetaInvalidRequestError()
	case "not_found_error":
		return t.AsBetaNotFoundError()
	case "overloaded_error":
		return t.AsBetaOverloadedError()
	case "permission_error":
		return t.AsBetaPermissionError()
	case "rate_limit_error":
		return t.AsBetaRateLimitError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaErrorResponse_Error) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaErrorResponse_Error) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaRequestTextBlock returns the union data inside the BetaInputContentBlock as a BetaRequestTextBlock
func (t BetaInputContentBlock) AsBetaRequestTextBlock() (BetaRequestTextBlock, error) {
	var body BetaRequestTextBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestTextBlock overwrites any union data inside the BetaInputContentBlock as the provided BetaRequestTextBlock
func (t *BetaInputContentBlock) FromBetaRequestTextBlock(v BetaRequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestTextBlock performs a merge with any union data inside the BetaInputContentBlock, using the provided BetaRequestTextBlock
func (t *BetaInputContentBlock) MergeBetaRequestTextBlock(v BetaRequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaRequestImageBlock returns the union data inside the BetaInputContentBlock as a BetaRequestImageBlock
func (t BetaInputContentBlock) AsBetaRequestImageBlock() (BetaRequestImageBlock, error) {
	var body BetaRequestImageBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestImageBlock overwrites any union data inside the BetaInputContentBlock as the provided BetaRequestImageBlock
func (t *BetaInputContentBlock) FromBetaRequestImageBlock(v BetaRequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestImageBlock performs a merge with any union data inside the BetaInputContentBlock, using the provided BetaRequestImageBlock
func (t *BetaInputContentBlock) MergeBetaRequestImageBlock(v BetaRequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaRequestToolUseBlock returns the union data inside the BetaInputContentBlock as a BetaRequestToolUseBlock
func (t BetaInputContentBlock) AsBetaRequestToolUseBlock() (BetaRequestToolUseBlock, error) {
	var body BetaRequestToolUseBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestToolUseBlock overwrites any union data inside the BetaInputContentBlock as the provided BetaRequestToolUseBlock
func (t *BetaInputContentBlock) FromBetaRequestToolUseBlock(v BetaRequestToolUseBlock) error {
	v.Type = "tool_use"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestToolUseBlock performs a merge with any union data inside the BetaInputContentBlock, using the provided BetaRequestToolUseBlock
func (t *BetaInputContentBlock) MergeBetaRequestToolUseBlock(v BetaRequestToolUseBlock) error {
	v.Type = "tool_use"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaRequestToolResultBlock returns the union data inside the BetaInputContentBlock as a BetaRequestToolResultBlock
func (t BetaInputContentBlock) AsBetaRequestToolResultBlock() (BetaRequestToolResultBlock, error) {
	var body BetaRequestToolResultBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestToolResultBlock overwrites any union data inside the BetaInputContentBlock as the provided BetaRequestToolResultBlock
func (t *BetaInputContentBlock) FromBetaRequestToolResultBlock(v BetaRequestToolResultBlock) error {
	v.Type = "tool_result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestToolResultBlock performs a merge with any union data inside the BetaInputContentBlock, using the provided BetaRequestToolResultBlock
func (t *BetaInputContentBlock) MergeBetaRequestToolResultBlock(v BetaRequestToolResultBlock) error {
	v.Type = "tool_result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaRequestPDFBlock returns the union data inside the BetaInputContentBlock as a BetaRequestPDFBlock
func (t BetaInputContentBlock) AsBetaRequestPDFBlock() (BetaRequestPDFBlock, error) {
	var body BetaRequestPDFBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestPDFBlock overwrites any union data inside the BetaInputContentBlock as the provided BetaRequestPDFBlock
func (t *BetaInputContentBlock) FromBetaRequestPDFBlock(v BetaRequestPDFBlock) error {
	v.Type = "document"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestPDFBlock performs a merge with any union data inside the BetaInputContentBlock, using the provided BetaRequestPDFBlock
func (t *BetaInputContentBlock) MergeBetaRequestPDFBlock(v BetaRequestPDFBlock) error {
	v.Type = "document"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaInputContentBlock) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaInputContentBlock) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "document":
		return t.AsBetaRequestPDFBlock()
	case "image":
		return t.AsBetaRequestImageBlock()
	case "text":
		return t.AsBetaRequestTextBlock()
	case "tool_result":
		return t.AsBetaRequestToolResultBlock()
	case "tool_use":
		return t.AsBetaRequestToolUseBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaInputContentBlock) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaInputContentBlock) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaInputMessageContent0 returns the union data inside the BetaInputMessage_Content as a BetaInputMessageContent0
func (t BetaInputMessage_Content) AsBetaInputMessageContent0() (BetaInputMessageContent0, error) {
	var body BetaInputMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaInputMessageContent0 overwrites any union data inside the BetaInputMessage_Content as the provided BetaInputMessageContent0
func (t *BetaInputMessage_Content) FromBetaInputMessageContent0(v BetaInputMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaInputMessageContent0 performs a merge with any union data inside the BetaInputMessage_Content, using the provided BetaInputMessageContent0
func (t *BetaInputMessage_Content) MergeBetaInputMessageContent0(v BetaInputMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaInputMessageContent1 returns the union data inside the BetaInputMessage_Content as a BetaInputMessageContent1
func (t BetaInputMessage_Content) AsBetaInputMessageContent1() (BetaInputMessageContent1, error) {
	var body BetaInputMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaInputMessageContent1 overwrites any union data inside the BetaInputMessage_Content as the provided BetaInputMessageContent1
func (t *BetaInputMessage_Content) FromBetaInputMessageContent1(v BetaInputMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaInputMessageContent1 performs a merge with any union data inside the BetaInputMessage_Content, using the provided BetaInputMessageContent1
func (t *BetaInputMessage_Content) MergeBetaInputMessageContent1(v BetaInputMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaInputMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaInputMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaInputSchemaProperties0 returns the union data inside the BetaInputSchema_Properties as a BetaInputSchemaProperties0
func (t BetaInputSchema_Properties) AsBetaInputSchemaProperties0() (BetaInputSchemaProperties0, error) {
	var body BetaInputSchemaProperties0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaInputSchemaProperties0 overwrites any union data inside the BetaInputSchema_Properties as the provided BetaInputSchemaProperties0
func (t *BetaInputSchema_Properties) FromBetaInputSchemaProperties0(v BetaInputSchemaProperties0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaInputSchemaProperties0 performs a merge with any union data inside the BetaInputSchema_Properties, using the provided BetaInputSchemaProperties0
func (t *BetaInputSchema_Properties) MergeBetaInputSchemaProperties0(v BetaInputSchemaProperties0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaInputSchema_Properties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaInputSchema_Properties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaListResponseMessageBatchFirstId0 returns the union data inside the BetaListResponseMessageBatch_FirstId as a BetaListResponseMessageBatchFirstId0
func (t BetaListResponseMessageBatch_FirstId) AsBetaListResponseMessageBatchFirstId0() (BetaListResponseMessageBatchFirstId0, error) {
	var body BetaListResponseMessageBatchFirstId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaListResponseMessageBatchFirstId0 overwrites any union data inside the BetaListResponseMessageBatch_FirstId as the provided BetaListResponseMessageBatchFirstId0
func (t *BetaListResponseMessageBatch_FirstId) FromBetaListResponseMessageBatchFirstId0(v BetaListResponseMessageBatchFirstId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaListResponseMessageBatchFirstId0 performs a merge with any union data inside the BetaListResponseMessageBatch_FirstId, using the provided BetaListResponseMessageBatchFirstId0
func (t *BetaListResponseMessageBatch_FirstId) MergeBetaListResponseMessageBatchFirstId0(v BetaListResponseMessageBatchFirstId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaListResponseMessageBatch_FirstId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaListResponseMessageBatch_FirstId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaListResponseMessageBatchLastId0 returns the union data inside the BetaListResponseMessageBatch_LastId as a BetaListResponseMessageBatchLastId0
func (t BetaListResponseMessageBatch_LastId) AsBetaListResponseMessageBatchLastId0() (BetaListResponseMessageBatchLastId0, error) {
	var body BetaListResponseMessageBatchLastId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaListResponseMessageBatchLastId0 overwrites any union data inside the BetaListResponseMessageBatch_LastId as the provided BetaListResponseMessageBatchLastId0
func (t *BetaListResponseMessageBatch_LastId) FromBetaListResponseMessageBatchLastId0(v BetaListResponseMessageBatchLastId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaListResponseMessageBatchLastId0 performs a merge with any union data inside the BetaListResponseMessageBatch_LastId, using the provided BetaListResponseMessageBatchLastId0
func (t *BetaListResponseMessageBatch_LastId) MergeBetaListResponseMessageBatchLastId0(v BetaListResponseMessageBatchLastId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaListResponseMessageBatch_LastId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaListResponseMessageBatch_LastId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaMessageBatchArchivedAt0 returns the union data inside the BetaMessageBatch_ArchivedAt as a BetaMessageBatchArchivedAt0
func (t BetaMessageBatch_ArchivedAt) AsBetaMessageBatchArchivedAt0() (BetaMessageBatchArchivedAt0, error) {
	var body BetaMessageBatchArchivedAt0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaMessageBatchArchivedAt0 overwrites any union data inside the BetaMessageBatch_ArchivedAt as the provided BetaMessageBatchArchivedAt0
func (t *BetaMessageBatch_ArchivedAt) FromBetaMessageBatchArchivedAt0(v BetaMessageBatchArchivedAt0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaMessageBatchArchivedAt0 performs a merge with any union data inside the BetaMessageBatch_ArchivedAt, using the provided BetaMessageBatchArchivedAt0
func (t *BetaMessageBatch_ArchivedAt) MergeBetaMessageBatchArchivedAt0(v BetaMessageBatchArchivedAt0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaMessageBatch_ArchivedAt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaMessageBatch_ArchivedAt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaMessageBatchCancelInitiatedAt0 returns the union data inside the BetaMessageBatch_CancelInitiatedAt as a BetaMessageBatchCancelInitiatedAt0
func (t BetaMessageBatch_CancelInitiatedAt) AsBetaMessageBatchCancelInitiatedAt0() (BetaMessageBatchCancelInitiatedAt0, error) {
	var body BetaMessageBatchCancelInitiatedAt0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaMessageBatchCancelInitiatedAt0 overwrites any union data inside the BetaMessageBatch_CancelInitiatedAt as the provided BetaMessageBatchCancelInitiatedAt0
func (t *BetaMessageBatch_CancelInitiatedAt) FromBetaMessageBatchCancelInitiatedAt0(v BetaMessageBatchCancelInitiatedAt0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaMessageBatchCancelInitiatedAt0 performs a merge with any union data inside the BetaMessageBatch_CancelInitiatedAt, using the provided BetaMessageBatchCancelInitiatedAt0
func (t *BetaMessageBatch_CancelInitiatedAt) MergeBetaMessageBatchCancelInitiatedAt0(v BetaMessageBatchCancelInitiatedAt0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaMessageBatch_CancelInitiatedAt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaMessageBatch_CancelInitiatedAt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaMessageBatchEndedAt0 returns the union data inside the BetaMessageBatch_EndedAt as a BetaMessageBatchEndedAt0
func (t BetaMessageBatch_EndedAt) AsBetaMessageBatchEndedAt0() (BetaMessageBatchEndedAt0, error) {
	var body BetaMessageBatchEndedAt0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaMessageBatchEndedAt0 overwrites any union data inside the BetaMessageBatch_EndedAt as the provided BetaMessageBatchEndedAt0
func (t *BetaMessageBatch_EndedAt) FromBetaMessageBatchEndedAt0(v BetaMessageBatchEndedAt0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaMessageBatchEndedAt0 performs a merge with any union data inside the BetaMessageBatch_EndedAt, using the provided BetaMessageBatchEndedAt0
func (t *BetaMessageBatch_EndedAt) MergeBetaMessageBatchEndedAt0(v BetaMessageBatchEndedAt0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaMessageBatch_EndedAt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaMessageBatch_EndedAt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaMessageBatchResultsUrl0 returns the union data inside the BetaMessageBatch_ResultsUrl as a BetaMessageBatchResultsUrl0
func (t BetaMessageBatch_ResultsUrl) AsBetaMessageBatchResultsUrl0() (BetaMessageBatchResultsUrl0, error) {
	var body BetaMessageBatchResultsUrl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaMessageBatchResultsUrl0 overwrites any union data inside the BetaMessageBatch_ResultsUrl as the provided BetaMessageBatchResultsUrl0
func (t *BetaMessageBatch_ResultsUrl) FromBetaMessageBatchResultsUrl0(v BetaMessageBatchResultsUrl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaMessageBatchResultsUrl0 performs a merge with any union data inside the BetaMessageBatch_ResultsUrl, using the provided BetaMessageBatchResultsUrl0
func (t *BetaMessageBatch_ResultsUrl) MergeBetaMessageBatchResultsUrl0(v BetaMessageBatchResultsUrl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaMessageBatch_ResultsUrl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaMessageBatch_ResultsUrl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaMetadataUserId0 returns the union data inside the BetaMetadata_UserId as a BetaMetadataUserId0
func (t BetaMetadata_UserId) AsBetaMetadataUserId0() (BetaMetadataUserId0, error) {
	var body BetaMetadataUserId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaMetadataUserId0 overwrites any union data inside the BetaMetadata_UserId as the provided BetaMetadataUserId0
func (t *BetaMetadata_UserId) FromBetaMetadataUserId0(v BetaMetadataUserId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaMetadataUserId0 performs a merge with any union data inside the BetaMetadata_UserId, using the provided BetaMetadataUserId0
func (t *BetaMetadata_UserId) MergeBetaMetadataUserId0(v BetaMetadataUserId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaMetadata_UserId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaMetadata_UserId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaCacheControlEphemeral returns the union data inside the BetaRequestImageBlockCacheControl0 as a BetaCacheControlEphemeral
func (t BetaRequestImageBlockCacheControl0) AsBetaCacheControlEphemeral() (BetaCacheControlEphemeral, error) {
	var body BetaCacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCacheControlEphemeral overwrites any union data inside the BetaRequestImageBlockCacheControl0 as the provided BetaCacheControlEphemeral
func (t *BetaRequestImageBlockCacheControl0) FromBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCacheControlEphemeral performs a merge with any union data inside the BetaRequestImageBlockCacheControl0, using the provided BetaCacheControlEphemeral
func (t *BetaRequestImageBlockCacheControl0) MergeBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestImageBlockCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaRequestImageBlockCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsBetaCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaRequestImageBlockCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestImageBlockCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaRequestImageBlockCacheControl0 returns the union data inside the BetaRequestImageBlock_CacheControl as a BetaRequestImageBlockCacheControl0
func (t BetaRequestImageBlock_CacheControl) AsBetaRequestImageBlockCacheControl0() (BetaRequestImageBlockCacheControl0, error) {
	var body BetaRequestImageBlockCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestImageBlockCacheControl0 overwrites any union data inside the BetaRequestImageBlock_CacheControl as the provided BetaRequestImageBlockCacheControl0
func (t *BetaRequestImageBlock_CacheControl) FromBetaRequestImageBlockCacheControl0(v BetaRequestImageBlockCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestImageBlockCacheControl0 performs a merge with any union data inside the BetaRequestImageBlock_CacheControl, using the provided BetaRequestImageBlockCacheControl0
func (t *BetaRequestImageBlock_CacheControl) MergeBetaRequestImageBlockCacheControl0(v BetaRequestImageBlockCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestImageBlock_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestImageBlock_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaBase64ImageSource returns the union data inside the BetaRequestImageBlock_Source as a BetaBase64ImageSource
func (t BetaRequestImageBlock_Source) AsBetaBase64ImageSource() (BetaBase64ImageSource, error) {
	var body BetaBase64ImageSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaBase64ImageSource overwrites any union data inside the BetaRequestImageBlock_Source as the provided BetaBase64ImageSource
func (t *BetaRequestImageBlock_Source) FromBetaBase64ImageSource(v BetaBase64ImageSource) error {
	v.Type = "base64"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaBase64ImageSource performs a merge with any union data inside the BetaRequestImageBlock_Source, using the provided BetaBase64ImageSource
func (t *BetaRequestImageBlock_Source) MergeBetaBase64ImageSource(v BetaBase64ImageSource) error {
	v.Type = "base64"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestImageBlock_Source) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaRequestImageBlock_Source) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "base64":
		return t.AsBetaBase64ImageSource()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaRequestImageBlock_Source) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestImageBlock_Source) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaCacheControlEphemeral returns the union data inside the BetaRequestPDFBlockCacheControl0 as a BetaCacheControlEphemeral
func (t BetaRequestPDFBlockCacheControl0) AsBetaCacheControlEphemeral() (BetaCacheControlEphemeral, error) {
	var body BetaCacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCacheControlEphemeral overwrites any union data inside the BetaRequestPDFBlockCacheControl0 as the provided BetaCacheControlEphemeral
func (t *BetaRequestPDFBlockCacheControl0) FromBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCacheControlEphemeral performs a merge with any union data inside the BetaRequestPDFBlockCacheControl0, using the provided BetaCacheControlEphemeral
func (t *BetaRequestPDFBlockCacheControl0) MergeBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestPDFBlockCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaRequestPDFBlockCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsBetaCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaRequestPDFBlockCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestPDFBlockCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaRequestPDFBlockCacheControl0 returns the union data inside the BetaRequestPDFBlock_CacheControl as a BetaRequestPDFBlockCacheControl0
func (t BetaRequestPDFBlock_CacheControl) AsBetaRequestPDFBlockCacheControl0() (BetaRequestPDFBlockCacheControl0, error) {
	var body BetaRequestPDFBlockCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestPDFBlockCacheControl0 overwrites any union data inside the BetaRequestPDFBlock_CacheControl as the provided BetaRequestPDFBlockCacheControl0
func (t *BetaRequestPDFBlock_CacheControl) FromBetaRequestPDFBlockCacheControl0(v BetaRequestPDFBlockCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestPDFBlockCacheControl0 performs a merge with any union data inside the BetaRequestPDFBlock_CacheControl, using the provided BetaRequestPDFBlockCacheControl0
func (t *BetaRequestPDFBlock_CacheControl) MergeBetaRequestPDFBlockCacheControl0(v BetaRequestPDFBlockCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestPDFBlock_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestPDFBlock_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaCacheControlEphemeral returns the union data inside the BetaRequestTextBlockCacheControl0 as a BetaCacheControlEphemeral
func (t BetaRequestTextBlockCacheControl0) AsBetaCacheControlEphemeral() (BetaCacheControlEphemeral, error) {
	var body BetaCacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCacheControlEphemeral overwrites any union data inside the BetaRequestTextBlockCacheControl0 as the provided BetaCacheControlEphemeral
func (t *BetaRequestTextBlockCacheControl0) FromBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCacheControlEphemeral performs a merge with any union data inside the BetaRequestTextBlockCacheControl0, using the provided BetaCacheControlEphemeral
func (t *BetaRequestTextBlockCacheControl0) MergeBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestTextBlockCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaRequestTextBlockCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsBetaCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaRequestTextBlockCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestTextBlockCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaRequestTextBlockCacheControl0 returns the union data inside the BetaRequestTextBlock_CacheControl as a BetaRequestTextBlockCacheControl0
func (t BetaRequestTextBlock_CacheControl) AsBetaRequestTextBlockCacheControl0() (BetaRequestTextBlockCacheControl0, error) {
	var body BetaRequestTextBlockCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestTextBlockCacheControl0 overwrites any union data inside the BetaRequestTextBlock_CacheControl as the provided BetaRequestTextBlockCacheControl0
func (t *BetaRequestTextBlock_CacheControl) FromBetaRequestTextBlockCacheControl0(v BetaRequestTextBlockCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestTextBlockCacheControl0 performs a merge with any union data inside the BetaRequestTextBlock_CacheControl, using the provided BetaRequestTextBlockCacheControl0
func (t *BetaRequestTextBlock_CacheControl) MergeBetaRequestTextBlockCacheControl0(v BetaRequestTextBlockCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestTextBlock_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestTextBlock_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaCacheControlEphemeral returns the union data inside the BetaRequestToolResultBlockCacheControl0 as a BetaCacheControlEphemeral
func (t BetaRequestToolResultBlockCacheControl0) AsBetaCacheControlEphemeral() (BetaCacheControlEphemeral, error) {
	var body BetaCacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCacheControlEphemeral overwrites any union data inside the BetaRequestToolResultBlockCacheControl0 as the provided BetaCacheControlEphemeral
func (t *BetaRequestToolResultBlockCacheControl0) FromBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCacheControlEphemeral performs a merge with any union data inside the BetaRequestToolResultBlockCacheControl0, using the provided BetaCacheControlEphemeral
func (t *BetaRequestToolResultBlockCacheControl0) MergeBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestToolResultBlockCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaRequestToolResultBlockCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsBetaCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaRequestToolResultBlockCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestToolResultBlockCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaRequestToolResultBlockCacheControl0 returns the union data inside the BetaRequestToolResultBlock_CacheControl as a BetaRequestToolResultBlockCacheControl0
func (t BetaRequestToolResultBlock_CacheControl) AsBetaRequestToolResultBlockCacheControl0() (BetaRequestToolResultBlockCacheControl0, error) {
	var body BetaRequestToolResultBlockCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestToolResultBlockCacheControl0 overwrites any union data inside the BetaRequestToolResultBlock_CacheControl as the provided BetaRequestToolResultBlockCacheControl0
func (t *BetaRequestToolResultBlock_CacheControl) FromBetaRequestToolResultBlockCacheControl0(v BetaRequestToolResultBlockCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestToolResultBlockCacheControl0 performs a merge with any union data inside the BetaRequestToolResultBlock_CacheControl, using the provided BetaRequestToolResultBlockCacheControl0
func (t *BetaRequestToolResultBlock_CacheControl) MergeBetaRequestToolResultBlockCacheControl0(v BetaRequestToolResultBlockCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestToolResultBlock_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestToolResultBlock_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaRequestTextBlock returns the union data inside the BetaRequestToolResultBlock_Content_1_Item as a BetaRequestTextBlock
func (t BetaRequestToolResultBlock_Content_1_Item) AsBetaRequestTextBlock() (BetaRequestTextBlock, error) {
	var body BetaRequestTextBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestTextBlock overwrites any union data inside the BetaRequestToolResultBlock_Content_1_Item as the provided BetaRequestTextBlock
func (t *BetaRequestToolResultBlock_Content_1_Item) FromBetaRequestTextBlock(v BetaRequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestTextBlock performs a merge with any union data inside the BetaRequestToolResultBlock_Content_1_Item, using the provided BetaRequestTextBlock
func (t *BetaRequestToolResultBlock_Content_1_Item) MergeBetaRequestTextBlock(v BetaRequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaRequestImageBlock returns the union data inside the BetaRequestToolResultBlock_Content_1_Item as a BetaRequestImageBlock
func (t BetaRequestToolResultBlock_Content_1_Item) AsBetaRequestImageBlock() (BetaRequestImageBlock, error) {
	var body BetaRequestImageBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestImageBlock overwrites any union data inside the BetaRequestToolResultBlock_Content_1_Item as the provided BetaRequestImageBlock
func (t *BetaRequestToolResultBlock_Content_1_Item) FromBetaRequestImageBlock(v BetaRequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestImageBlock performs a merge with any union data inside the BetaRequestToolResultBlock_Content_1_Item, using the provided BetaRequestImageBlock
func (t *BetaRequestToolResultBlock_Content_1_Item) MergeBetaRequestImageBlock(v BetaRequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestToolResultBlock_Content_1_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaRequestToolResultBlock_Content_1_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "image":
		return t.AsBetaRequestImageBlock()
	case "text":
		return t.AsBetaRequestTextBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaRequestToolResultBlock_Content_1_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestToolResultBlock_Content_1_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaRequestToolResultBlockContent0 returns the union data inside the BetaRequestToolResultBlock_Content as a BetaRequestToolResultBlockContent0
func (t BetaRequestToolResultBlock_Content) AsBetaRequestToolResultBlockContent0() (BetaRequestToolResultBlockContent0, error) {
	var body BetaRequestToolResultBlockContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestToolResultBlockContent0 overwrites any union data inside the BetaRequestToolResultBlock_Content as the provided BetaRequestToolResultBlockContent0
func (t *BetaRequestToolResultBlock_Content) FromBetaRequestToolResultBlockContent0(v BetaRequestToolResultBlockContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestToolResultBlockContent0 performs a merge with any union data inside the BetaRequestToolResultBlock_Content, using the provided BetaRequestToolResultBlockContent0
func (t *BetaRequestToolResultBlock_Content) MergeBetaRequestToolResultBlockContent0(v BetaRequestToolResultBlockContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaRequestToolResultBlockContent1 returns the union data inside the BetaRequestToolResultBlock_Content as a BetaRequestToolResultBlockContent1
func (t BetaRequestToolResultBlock_Content) AsBetaRequestToolResultBlockContent1() (BetaRequestToolResultBlockContent1, error) {
	var body BetaRequestToolResultBlockContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestToolResultBlockContent1 overwrites any union data inside the BetaRequestToolResultBlock_Content as the provided BetaRequestToolResultBlockContent1
func (t *BetaRequestToolResultBlock_Content) FromBetaRequestToolResultBlockContent1(v BetaRequestToolResultBlockContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestToolResultBlockContent1 performs a merge with any union data inside the BetaRequestToolResultBlock_Content, using the provided BetaRequestToolResultBlockContent1
func (t *BetaRequestToolResultBlock_Content) MergeBetaRequestToolResultBlockContent1(v BetaRequestToolResultBlockContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestToolResultBlock_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestToolResultBlock_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaCacheControlEphemeral returns the union data inside the BetaRequestToolUseBlockCacheControl0 as a BetaCacheControlEphemeral
func (t BetaRequestToolUseBlockCacheControl0) AsBetaCacheControlEphemeral() (BetaCacheControlEphemeral, error) {
	var body BetaCacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCacheControlEphemeral overwrites any union data inside the BetaRequestToolUseBlockCacheControl0 as the provided BetaCacheControlEphemeral
func (t *BetaRequestToolUseBlockCacheControl0) FromBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCacheControlEphemeral performs a merge with any union data inside the BetaRequestToolUseBlockCacheControl0, using the provided BetaCacheControlEphemeral
func (t *BetaRequestToolUseBlockCacheControl0) MergeBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestToolUseBlockCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaRequestToolUseBlockCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsBetaCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaRequestToolUseBlockCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestToolUseBlockCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaRequestToolUseBlockCacheControl0 returns the union data inside the BetaRequestToolUseBlock_CacheControl as a BetaRequestToolUseBlockCacheControl0
func (t BetaRequestToolUseBlock_CacheControl) AsBetaRequestToolUseBlockCacheControl0() (BetaRequestToolUseBlockCacheControl0, error) {
	var body BetaRequestToolUseBlockCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaRequestToolUseBlockCacheControl0 overwrites any union data inside the BetaRequestToolUseBlock_CacheControl as the provided BetaRequestToolUseBlockCacheControl0
func (t *BetaRequestToolUseBlock_CacheControl) FromBetaRequestToolUseBlockCacheControl0(v BetaRequestToolUseBlockCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaRequestToolUseBlockCacheControl0 performs a merge with any union data inside the BetaRequestToolUseBlock_CacheControl, using the provided BetaRequestToolUseBlockCacheControl0
func (t *BetaRequestToolUseBlock_CacheControl) MergeBetaRequestToolUseBlockCacheControl0(v BetaRequestToolUseBlockCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaRequestToolUseBlock_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaRequestToolUseBlock_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaCacheControlEphemeral returns the union data inside the BetaTextEditor20241022CacheControl0 as a BetaCacheControlEphemeral
func (t BetaTextEditor20241022CacheControl0) AsBetaCacheControlEphemeral() (BetaCacheControlEphemeral, error) {
	var body BetaCacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCacheControlEphemeral overwrites any union data inside the BetaTextEditor20241022CacheControl0 as the provided BetaCacheControlEphemeral
func (t *BetaTextEditor20241022CacheControl0) FromBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCacheControlEphemeral performs a merge with any union data inside the BetaTextEditor20241022CacheControl0, using the provided BetaCacheControlEphemeral
func (t *BetaTextEditor20241022CacheControl0) MergeBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaTextEditor20241022CacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaTextEditor20241022CacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsBetaCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaTextEditor20241022CacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaTextEditor20241022CacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaTextEditor20241022CacheControl0 returns the union data inside the BetaTextEditor20241022_CacheControl as a BetaTextEditor20241022CacheControl0
func (t BetaTextEditor20241022_CacheControl) AsBetaTextEditor20241022CacheControl0() (BetaTextEditor20241022CacheControl0, error) {
	var body BetaTextEditor20241022CacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaTextEditor20241022CacheControl0 overwrites any union data inside the BetaTextEditor20241022_CacheControl as the provided BetaTextEditor20241022CacheControl0
func (t *BetaTextEditor20241022_CacheControl) FromBetaTextEditor20241022CacheControl0(v BetaTextEditor20241022CacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaTextEditor20241022CacheControl0 performs a merge with any union data inside the BetaTextEditor20241022_CacheControl, using the provided BetaTextEditor20241022CacheControl0
func (t *BetaTextEditor20241022_CacheControl) MergeBetaTextEditor20241022CacheControl0(v BetaTextEditor20241022CacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaTextEditor20241022_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaTextEditor20241022_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaCacheControlEphemeral returns the union data inside the BetaToolCacheControl0 as a BetaCacheControlEphemeral
func (t BetaToolCacheControl0) AsBetaCacheControlEphemeral() (BetaCacheControlEphemeral, error) {
	var body BetaCacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaCacheControlEphemeral overwrites any union data inside the BetaToolCacheControl0 as the provided BetaCacheControlEphemeral
func (t *BetaToolCacheControl0) FromBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaCacheControlEphemeral performs a merge with any union data inside the BetaToolCacheControl0, using the provided BetaCacheControlEphemeral
func (t *BetaToolCacheControl0) MergeBetaCacheControlEphemeral(v BetaCacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaToolCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaToolCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsBetaCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaToolCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaToolCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaToolCacheControl0 returns the union data inside the BetaTool_CacheControl as a BetaToolCacheControl0
func (t BetaTool_CacheControl) AsBetaToolCacheControl0() (BetaToolCacheControl0, error) {
	var body BetaToolCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaToolCacheControl0 overwrites any union data inside the BetaTool_CacheControl as the provided BetaToolCacheControl0
func (t *BetaTool_CacheControl) FromBetaToolCacheControl0(v BetaToolCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaToolCacheControl0 performs a merge with any union data inside the BetaTool_CacheControl, using the provided BetaToolCacheControl0
func (t *BetaTool_CacheControl) MergeBetaToolCacheControl0(v BetaToolCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaTool_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaTool_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaToolType0 returns the union data inside the BetaTool_Type as a BetaToolType0
func (t BetaTool_Type) AsBetaToolType0() (BetaToolType0, error) {
	var body BetaToolType0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaToolType0 overwrites any union data inside the BetaTool_Type as the provided BetaToolType0
func (t *BetaTool_Type) FromBetaToolType0(v BetaToolType0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaToolType0 performs a merge with any union data inside the BetaTool_Type, using the provided BetaToolType0
func (t *BetaTool_Type) MergeBetaToolType0(v BetaToolType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaTool_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaTool_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBetaToolChoiceAuto returns the union data inside the BetaToolChoice as a BetaToolChoiceAuto
func (t BetaToolChoice) AsBetaToolChoiceAuto() (BetaToolChoiceAuto, error) {
	var body BetaToolChoiceAuto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaToolChoiceAuto overwrites any union data inside the BetaToolChoice as the provided BetaToolChoiceAuto
func (t *BetaToolChoice) FromBetaToolChoiceAuto(v BetaToolChoiceAuto) error {
	v.Type = "auto"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaToolChoiceAuto performs a merge with any union data inside the BetaToolChoice, using the provided BetaToolChoiceAuto
func (t *BetaToolChoice) MergeBetaToolChoiceAuto(v BetaToolChoiceAuto) error {
	v.Type = "auto"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaToolChoiceAny returns the union data inside the BetaToolChoice as a BetaToolChoiceAny
func (t BetaToolChoice) AsBetaToolChoiceAny() (BetaToolChoiceAny, error) {
	var body BetaToolChoiceAny
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaToolChoiceAny overwrites any union data inside the BetaToolChoice as the provided BetaToolChoiceAny
func (t *BetaToolChoice) FromBetaToolChoiceAny(v BetaToolChoiceAny) error {
	v.Type = "any"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaToolChoiceAny performs a merge with any union data inside the BetaToolChoice, using the provided BetaToolChoiceAny
func (t *BetaToolChoice) MergeBetaToolChoiceAny(v BetaToolChoiceAny) error {
	v.Type = "any"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBetaToolChoiceTool returns the union data inside the BetaToolChoice as a BetaToolChoiceTool
func (t BetaToolChoice) AsBetaToolChoiceTool() (BetaToolChoiceTool, error) {
	var body BetaToolChoiceTool
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBetaToolChoiceTool overwrites any union data inside the BetaToolChoice as the provided BetaToolChoiceTool
func (t *BetaToolChoice) FromBetaToolChoiceTool(v BetaToolChoiceTool) error {
	v.Type = "tool"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBetaToolChoiceTool performs a merge with any union data inside the BetaToolChoice, using the provided BetaToolChoiceTool
func (t *BetaToolChoice) MergeBetaToolChoiceTool(v BetaToolChoiceTool) error {
	v.Type = "tool"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BetaToolChoice) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BetaToolChoice) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "any":
		return t.AsBetaToolChoiceAny()
	case "auto":
		return t.AsBetaToolChoiceAuto()
	case "tool":
		return t.AsBetaToolChoiceTool()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BetaToolChoice) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BetaToolChoice) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCompletionResponseStopReason0 returns the union data inside the CompletionResponse_StopReason as a CompletionResponseStopReason0
func (t CompletionResponse_StopReason) AsCompletionResponseStopReason0() (CompletionResponseStopReason0, error) {
	var body CompletionResponseStopReason0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompletionResponseStopReason0 overwrites any union data inside the CompletionResponse_StopReason as the provided CompletionResponseStopReason0
func (t *CompletionResponse_StopReason) FromCompletionResponseStopReason0(v CompletionResponseStopReason0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompletionResponseStopReason0 performs a merge with any union data inside the CompletionResponse_StopReason, using the provided CompletionResponseStopReason0
func (t *CompletionResponse_StopReason) MergeCompletionResponseStopReason0(v CompletionResponseStopReason0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CompletionResponse_StopReason) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CompletionResponse_StopReason) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResponseTextBlock returns the union data inside the ContentBlock as a ResponseTextBlock
func (t ContentBlock) AsResponseTextBlock() (ResponseTextBlock, error) {
	var body ResponseTextBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseTextBlock overwrites any union data inside the ContentBlock as the provided ResponseTextBlock
func (t *ContentBlock) FromResponseTextBlock(v ResponseTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseTextBlock performs a merge with any union data inside the ContentBlock, using the provided ResponseTextBlock
func (t *ContentBlock) MergeResponseTextBlock(v ResponseTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseToolUseBlock returns the union data inside the ContentBlock as a ResponseToolUseBlock
func (t ContentBlock) AsResponseToolUseBlock() (ResponseToolUseBlock, error) {
	var body ResponseToolUseBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseToolUseBlock overwrites any union data inside the ContentBlock as the provided ResponseToolUseBlock
func (t *ContentBlock) FromResponseToolUseBlock(v ResponseToolUseBlock) error {
	v.Type = "tool_use"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseToolUseBlock performs a merge with any union data inside the ContentBlock, using the provided ResponseToolUseBlock
func (t *ContentBlock) MergeResponseToolUseBlock(v ResponseToolUseBlock) error {
	v.Type = "tool_use"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContentBlock) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ContentBlock) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "text":
		return t.AsResponseTextBlock()
	case "tool_use":
		return t.AsResponseToolUseBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ContentBlock) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContentBlock) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateMessageParamsSystem0 returns the union data inside the CreateMessageParams_System as a CreateMessageParamsSystem0
func (t CreateMessageParams_System) AsCreateMessageParamsSystem0() (CreateMessageParamsSystem0, error) {
	var body CreateMessageParamsSystem0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMessageParamsSystem0 overwrites any union data inside the CreateMessageParams_System as the provided CreateMessageParamsSystem0
func (t *CreateMessageParams_System) FromCreateMessageParamsSystem0(v CreateMessageParamsSystem0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMessageParamsSystem0 performs a merge with any union data inside the CreateMessageParams_System, using the provided CreateMessageParamsSystem0
func (t *CreateMessageParams_System) MergeCreateMessageParamsSystem0(v CreateMessageParamsSystem0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMessageParamsSystem1 returns the union data inside the CreateMessageParams_System as a CreateMessageParamsSystem1
func (t CreateMessageParams_System) AsCreateMessageParamsSystem1() (CreateMessageParamsSystem1, error) {
	var body CreateMessageParamsSystem1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMessageParamsSystem1 overwrites any union data inside the CreateMessageParams_System as the provided CreateMessageParamsSystem1
func (t *CreateMessageParams_System) FromCreateMessageParamsSystem1(v CreateMessageParamsSystem1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMessageParamsSystem1 performs a merge with any union data inside the CreateMessageParams_System, using the provided CreateMessageParamsSystem1
func (t *CreateMessageParams_System) MergeCreateMessageParamsSystem1(v CreateMessageParamsSystem1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateMessageParams_System) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateMessageParams_System) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvalidRequestError returns the union data inside the ErrorResponse_Error as a InvalidRequestError
func (t ErrorResponse_Error) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ErrorResponse_Error as the provided InvalidRequestError
func (t *ErrorResponse_Error) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "invalid_request_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ErrorResponse_Error, using the provided InvalidRequestError
func (t *ErrorResponse_Error) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "invalid_request_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthenticationError returns the union data inside the ErrorResponse_Error as a AuthenticationError
func (t ErrorResponse_Error) AsAuthenticationError() (AuthenticationError, error) {
	var body AuthenticationError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthenticationError overwrites any union data inside the ErrorResponse_Error as the provided AuthenticationError
func (t *ErrorResponse_Error) FromAuthenticationError(v AuthenticationError) error {
	v.Type = "authentication_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthenticationError performs a merge with any union data inside the ErrorResponse_Error, using the provided AuthenticationError
func (t *ErrorResponse_Error) MergeAuthenticationError(v AuthenticationError) error {
	v.Type = "authentication_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPermissionError returns the union data inside the ErrorResponse_Error as a PermissionError
func (t ErrorResponse_Error) AsPermissionError() (PermissionError, error) {
	var body PermissionError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPermissionError overwrites any union data inside the ErrorResponse_Error as the provided PermissionError
func (t *ErrorResponse_Error) FromPermissionError(v PermissionError) error {
	v.Type = "permission_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePermissionError performs a merge with any union data inside the ErrorResponse_Error, using the provided PermissionError
func (t *ErrorResponse_Error) MergePermissionError(v PermissionError) error {
	v.Type = "permission_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotFoundError returns the union data inside the ErrorResponse_Error as a NotFoundError
func (t ErrorResponse_Error) AsNotFoundError() (NotFoundError, error) {
	var body NotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotFoundError overwrites any union data inside the ErrorResponse_Error as the provided NotFoundError
func (t *ErrorResponse_Error) FromNotFoundError(v NotFoundError) error {
	v.Type = "not_found_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotFoundError performs a merge with any union data inside the ErrorResponse_Error, using the provided NotFoundError
func (t *ErrorResponse_Error) MergeNotFoundError(v NotFoundError) error {
	v.Type = "not_found_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRateLimitError returns the union data inside the ErrorResponse_Error as a RateLimitError
func (t ErrorResponse_Error) AsRateLimitError() (RateLimitError, error) {
	var body RateLimitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateLimitError overwrites any union data inside the ErrorResponse_Error as the provided RateLimitError
func (t *ErrorResponse_Error) FromRateLimitError(v RateLimitError) error {
	v.Type = "rate_limit_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateLimitError performs a merge with any union data inside the ErrorResponse_Error, using the provided RateLimitError
func (t *ErrorResponse_Error) MergeRateLimitError(v RateLimitError) error {
	v.Type = "rate_limit_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAPIError returns the union data inside the ErrorResponse_Error as a APIError
func (t ErrorResponse_Error) AsAPIError() (APIError, error) {
	var body APIError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAPIError overwrites any union data inside the ErrorResponse_Error as the provided APIError
func (t *ErrorResponse_Error) FromAPIError(v APIError) error {
	v.Type = "api_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAPIError performs a merge with any union data inside the ErrorResponse_Error, using the provided APIError
func (t *ErrorResponse_Error) MergeAPIError(v APIError) error {
	v.Type = "api_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOverloadedError returns the union data inside the ErrorResponse_Error as a OverloadedError
func (t ErrorResponse_Error) AsOverloadedError() (OverloadedError, error) {
	var body OverloadedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOverloadedError overwrites any union data inside the ErrorResponse_Error as the provided OverloadedError
func (t *ErrorResponse_Error) FromOverloadedError(v OverloadedError) error {
	v.Type = "overloaded_error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOverloadedError performs a merge with any union data inside the ErrorResponse_Error, using the provided OverloadedError
func (t *ErrorResponse_Error) MergeOverloadedError(v OverloadedError) error {
	v.Type = "overloaded_error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorResponse_Error) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ErrorResponse_Error) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "api_error":
		return t.AsAPIError()
	case "authentication_error":
		return t.AsAuthenticationError()
	case "invalid_request_error":
		return t.AsInvalidRequestError()
	case "not_found_error":
		return t.AsNotFoundError()
	case "overloaded_error":
		return t.AsOverloadedError()
	case "permission_error":
		return t.AsPermissionError()
	case "rate_limit_error":
		return t.AsRateLimitError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ErrorResponse_Error) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ErrorResponse_Error) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRequestTextBlock returns the union data inside the InputMessage_Content_1_Item as a RequestTextBlock
func (t InputMessage_Content_1_Item) AsRequestTextBlock() (RequestTextBlock, error) {
	var body RequestTextBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestTextBlock overwrites any union data inside the InputMessage_Content_1_Item as the provided RequestTextBlock
func (t *InputMessage_Content_1_Item) FromRequestTextBlock(v RequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestTextBlock performs a merge with any union data inside the InputMessage_Content_1_Item, using the provided RequestTextBlock
func (t *InputMessage_Content_1_Item) MergeRequestTextBlock(v RequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestImageBlock returns the union data inside the InputMessage_Content_1_Item as a RequestImageBlock
func (t InputMessage_Content_1_Item) AsRequestImageBlock() (RequestImageBlock, error) {
	var body RequestImageBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestImageBlock overwrites any union data inside the InputMessage_Content_1_Item as the provided RequestImageBlock
func (t *InputMessage_Content_1_Item) FromRequestImageBlock(v RequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestImageBlock performs a merge with any union data inside the InputMessage_Content_1_Item, using the provided RequestImageBlock
func (t *InputMessage_Content_1_Item) MergeRequestImageBlock(v RequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestToolUseBlock returns the union data inside the InputMessage_Content_1_Item as a RequestToolUseBlock
func (t InputMessage_Content_1_Item) AsRequestToolUseBlock() (RequestToolUseBlock, error) {
	var body RequestToolUseBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestToolUseBlock overwrites any union data inside the InputMessage_Content_1_Item as the provided RequestToolUseBlock
func (t *InputMessage_Content_1_Item) FromRequestToolUseBlock(v RequestToolUseBlock) error {
	v.Type = "tool_use"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestToolUseBlock performs a merge with any union data inside the InputMessage_Content_1_Item, using the provided RequestToolUseBlock
func (t *InputMessage_Content_1_Item) MergeRequestToolUseBlock(v RequestToolUseBlock) error {
	v.Type = "tool_use"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestToolResultBlock returns the union data inside the InputMessage_Content_1_Item as a RequestToolResultBlock
func (t InputMessage_Content_1_Item) AsRequestToolResultBlock() (RequestToolResultBlock, error) {
	var body RequestToolResultBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestToolResultBlock overwrites any union data inside the InputMessage_Content_1_Item as the provided RequestToolResultBlock
func (t *InputMessage_Content_1_Item) FromRequestToolResultBlock(v RequestToolResultBlock) error {
	v.Type = "tool_result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestToolResultBlock performs a merge with any union data inside the InputMessage_Content_1_Item, using the provided RequestToolResultBlock
func (t *InputMessage_Content_1_Item) MergeRequestToolResultBlock(v RequestToolResultBlock) error {
	v.Type = "tool_result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InputMessage_Content_1_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t InputMessage_Content_1_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "image":
		return t.AsRequestImageBlock()
	case "text":
		return t.AsRequestTextBlock()
	case "tool_result":
		return t.AsRequestToolResultBlock()
	case "tool_use":
		return t.AsRequestToolUseBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t InputMessage_Content_1_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InputMessage_Content_1_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInputMessageContent0 returns the union data inside the InputMessage_Content as a InputMessageContent0
func (t InputMessage_Content) AsInputMessageContent0() (InputMessageContent0, error) {
	var body InputMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInputMessageContent0 overwrites any union data inside the InputMessage_Content as the provided InputMessageContent0
func (t *InputMessage_Content) FromInputMessageContent0(v InputMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInputMessageContent0 performs a merge with any union data inside the InputMessage_Content, using the provided InputMessageContent0
func (t *InputMessage_Content) MergeInputMessageContent0(v InputMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInputMessageContent1 returns the union data inside the InputMessage_Content as a InputMessageContent1
func (t InputMessage_Content) AsInputMessageContent1() (InputMessageContent1, error) {
	var body InputMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInputMessageContent1 overwrites any union data inside the InputMessage_Content as the provided InputMessageContent1
func (t *InputMessage_Content) FromInputMessageContent1(v InputMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInputMessageContent1 performs a merge with any union data inside the InputMessage_Content, using the provided InputMessageContent1
func (t *InputMessage_Content) MergeInputMessageContent1(v InputMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InputMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InputMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInputSchemaProperties0 returns the union data inside the InputSchema_Properties as a InputSchemaProperties0
func (t InputSchema_Properties) AsInputSchemaProperties0() (InputSchemaProperties0, error) {
	var body InputSchemaProperties0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInputSchemaProperties0 overwrites any union data inside the InputSchema_Properties as the provided InputSchemaProperties0
func (t *InputSchema_Properties) FromInputSchemaProperties0(v InputSchemaProperties0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInputSchemaProperties0 performs a merge with any union data inside the InputSchema_Properties, using the provided InputSchemaProperties0
func (t *InputSchema_Properties) MergeInputSchemaProperties0(v InputSchemaProperties0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InputSchema_Properties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InputSchema_Properties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageStopReason0 returns the union data inside the Message_StopReason as a MessageStopReason0
func (t Message_StopReason) AsMessageStopReason0() (MessageStopReason0, error) {
	var body MessageStopReason0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageStopReason0 overwrites any union data inside the Message_StopReason as the provided MessageStopReason0
func (t *Message_StopReason) FromMessageStopReason0(v MessageStopReason0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageStopReason0 performs a merge with any union data inside the Message_StopReason, using the provided MessageStopReason0
func (t *Message_StopReason) MergeMessageStopReason0(v MessageStopReason0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Message_StopReason) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Message_StopReason) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageStopSequence0 returns the union data inside the Message_StopSequence as a MessageStopSequence0
func (t Message_StopSequence) AsMessageStopSequence0() (MessageStopSequence0, error) {
	var body MessageStopSequence0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageStopSequence0 overwrites any union data inside the Message_StopSequence as the provided MessageStopSequence0
func (t *Message_StopSequence) FromMessageStopSequence0(v MessageStopSequence0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageStopSequence0 performs a merge with any union data inside the Message_StopSequence, using the provided MessageStopSequence0
func (t *Message_StopSequence) MergeMessageStopSequence0(v MessageStopSequence0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Message_StopSequence) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Message_StopSequence) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMetadataUserId0 returns the union data inside the Metadata_UserId as a MetadataUserId0
func (t Metadata_UserId) AsMetadataUserId0() (MetadataUserId0, error) {
	var body MetadataUserId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetadataUserId0 overwrites any union data inside the Metadata_UserId as the provided MetadataUserId0
func (t *Metadata_UserId) FromMetadataUserId0(v MetadataUserId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetadataUserId0 performs a merge with any union data inside the Metadata_UserId, using the provided MetadataUserId0
func (t *Metadata_UserId) MergeMetadataUserId0(v MetadataUserId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Metadata_UserId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Metadata_UserId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModel0 returns the union data inside the Model as a Model0
func (t Model) AsModel0() (Model0, error) {
	var body Model0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModel0 overwrites any union data inside the Model as the provided Model0
func (t *Model) FromModel0(v Model0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModel0 performs a merge with any union data inside the Model, using the provided Model0
func (t *Model) MergeModel0(v Model0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModel1 returns the union data inside the Model as a Model1
func (t Model) AsModel1() (Model1, error) {
	var body Model1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModel1 overwrites any union data inside the Model as the provided Model1
func (t *Model) FromModel1(v Model1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModel1 performs a merge with any union data inside the Model, using the provided Model1
func (t *Model) MergeModel1(v Model1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaCreateMessageParamsSystem0 returns the union data inside the PromptCachingBetaCreateMessageParams_System as a PromptCachingBetaCreateMessageParamsSystem0
func (t PromptCachingBetaCreateMessageParams_System) AsPromptCachingBetaCreateMessageParamsSystem0() (PromptCachingBetaCreateMessageParamsSystem0, error) {
	var body PromptCachingBetaCreateMessageParamsSystem0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaCreateMessageParamsSystem0 overwrites any union data inside the PromptCachingBetaCreateMessageParams_System as the provided PromptCachingBetaCreateMessageParamsSystem0
func (t *PromptCachingBetaCreateMessageParams_System) FromPromptCachingBetaCreateMessageParamsSystem0(v PromptCachingBetaCreateMessageParamsSystem0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaCreateMessageParamsSystem0 performs a merge with any union data inside the PromptCachingBetaCreateMessageParams_System, using the provided PromptCachingBetaCreateMessageParamsSystem0
func (t *PromptCachingBetaCreateMessageParams_System) MergePromptCachingBetaCreateMessageParamsSystem0(v PromptCachingBetaCreateMessageParamsSystem0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromptCachingBetaCreateMessageParamsSystem1 returns the union data inside the PromptCachingBetaCreateMessageParams_System as a PromptCachingBetaCreateMessageParamsSystem1
func (t PromptCachingBetaCreateMessageParams_System) AsPromptCachingBetaCreateMessageParamsSystem1() (PromptCachingBetaCreateMessageParamsSystem1, error) {
	var body PromptCachingBetaCreateMessageParamsSystem1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaCreateMessageParamsSystem1 overwrites any union data inside the PromptCachingBetaCreateMessageParams_System as the provided PromptCachingBetaCreateMessageParamsSystem1
func (t *PromptCachingBetaCreateMessageParams_System) FromPromptCachingBetaCreateMessageParamsSystem1(v PromptCachingBetaCreateMessageParamsSystem1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaCreateMessageParamsSystem1 performs a merge with any union data inside the PromptCachingBetaCreateMessageParams_System, using the provided PromptCachingBetaCreateMessageParamsSystem1
func (t *PromptCachingBetaCreateMessageParams_System) MergePromptCachingBetaCreateMessageParamsSystem1(v PromptCachingBetaCreateMessageParamsSystem1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaCreateMessageParams_System) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaCreateMessageParams_System) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaRequestTextBlock returns the union data inside the PromptCachingBetaInputMessage_Content_1_Item as a PromptCachingBetaRequestTextBlock
func (t PromptCachingBetaInputMessage_Content_1_Item) AsPromptCachingBetaRequestTextBlock() (PromptCachingBetaRequestTextBlock, error) {
	var body PromptCachingBetaRequestTextBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestTextBlock overwrites any union data inside the PromptCachingBetaInputMessage_Content_1_Item as the provided PromptCachingBetaRequestTextBlock
func (t *PromptCachingBetaInputMessage_Content_1_Item) FromPromptCachingBetaRequestTextBlock(v PromptCachingBetaRequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestTextBlock performs a merge with any union data inside the PromptCachingBetaInputMessage_Content_1_Item, using the provided PromptCachingBetaRequestTextBlock
func (t *PromptCachingBetaInputMessage_Content_1_Item) MergePromptCachingBetaRequestTextBlock(v PromptCachingBetaRequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromptCachingBetaRequestImageBlock returns the union data inside the PromptCachingBetaInputMessage_Content_1_Item as a PromptCachingBetaRequestImageBlock
func (t PromptCachingBetaInputMessage_Content_1_Item) AsPromptCachingBetaRequestImageBlock() (PromptCachingBetaRequestImageBlock, error) {
	var body PromptCachingBetaRequestImageBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestImageBlock overwrites any union data inside the PromptCachingBetaInputMessage_Content_1_Item as the provided PromptCachingBetaRequestImageBlock
func (t *PromptCachingBetaInputMessage_Content_1_Item) FromPromptCachingBetaRequestImageBlock(v PromptCachingBetaRequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestImageBlock performs a merge with any union data inside the PromptCachingBetaInputMessage_Content_1_Item, using the provided PromptCachingBetaRequestImageBlock
func (t *PromptCachingBetaInputMessage_Content_1_Item) MergePromptCachingBetaRequestImageBlock(v PromptCachingBetaRequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromptCachingBetaRequestToolUseBlock returns the union data inside the PromptCachingBetaInputMessage_Content_1_Item as a PromptCachingBetaRequestToolUseBlock
func (t PromptCachingBetaInputMessage_Content_1_Item) AsPromptCachingBetaRequestToolUseBlock() (PromptCachingBetaRequestToolUseBlock, error) {
	var body PromptCachingBetaRequestToolUseBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestToolUseBlock overwrites any union data inside the PromptCachingBetaInputMessage_Content_1_Item as the provided PromptCachingBetaRequestToolUseBlock
func (t *PromptCachingBetaInputMessage_Content_1_Item) FromPromptCachingBetaRequestToolUseBlock(v PromptCachingBetaRequestToolUseBlock) error {
	v.Type = "tool_use"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestToolUseBlock performs a merge with any union data inside the PromptCachingBetaInputMessage_Content_1_Item, using the provided PromptCachingBetaRequestToolUseBlock
func (t *PromptCachingBetaInputMessage_Content_1_Item) MergePromptCachingBetaRequestToolUseBlock(v PromptCachingBetaRequestToolUseBlock) error {
	v.Type = "tool_use"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromptCachingBetaRequestToolResultBlock returns the union data inside the PromptCachingBetaInputMessage_Content_1_Item as a PromptCachingBetaRequestToolResultBlock
func (t PromptCachingBetaInputMessage_Content_1_Item) AsPromptCachingBetaRequestToolResultBlock() (PromptCachingBetaRequestToolResultBlock, error) {
	var body PromptCachingBetaRequestToolResultBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestToolResultBlock overwrites any union data inside the PromptCachingBetaInputMessage_Content_1_Item as the provided PromptCachingBetaRequestToolResultBlock
func (t *PromptCachingBetaInputMessage_Content_1_Item) FromPromptCachingBetaRequestToolResultBlock(v PromptCachingBetaRequestToolResultBlock) error {
	v.Type = "tool_result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestToolResultBlock performs a merge with any union data inside the PromptCachingBetaInputMessage_Content_1_Item, using the provided PromptCachingBetaRequestToolResultBlock
func (t *PromptCachingBetaInputMessage_Content_1_Item) MergePromptCachingBetaRequestToolResultBlock(v PromptCachingBetaRequestToolResultBlock) error {
	v.Type = "tool_result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaInputMessage_Content_1_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromptCachingBetaInputMessage_Content_1_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "image":
		return t.AsPromptCachingBetaRequestImageBlock()
	case "text":
		return t.AsPromptCachingBetaRequestTextBlock()
	case "tool_result":
		return t.AsPromptCachingBetaRequestToolResultBlock()
	case "tool_use":
		return t.AsPromptCachingBetaRequestToolUseBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromptCachingBetaInputMessage_Content_1_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaInputMessage_Content_1_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaInputMessageContent0 returns the union data inside the PromptCachingBetaInputMessage_Content as a PromptCachingBetaInputMessageContent0
func (t PromptCachingBetaInputMessage_Content) AsPromptCachingBetaInputMessageContent0() (PromptCachingBetaInputMessageContent0, error) {
	var body PromptCachingBetaInputMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaInputMessageContent0 overwrites any union data inside the PromptCachingBetaInputMessage_Content as the provided PromptCachingBetaInputMessageContent0
func (t *PromptCachingBetaInputMessage_Content) FromPromptCachingBetaInputMessageContent0(v PromptCachingBetaInputMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaInputMessageContent0 performs a merge with any union data inside the PromptCachingBetaInputMessage_Content, using the provided PromptCachingBetaInputMessageContent0
func (t *PromptCachingBetaInputMessage_Content) MergePromptCachingBetaInputMessageContent0(v PromptCachingBetaInputMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromptCachingBetaInputMessageContent1 returns the union data inside the PromptCachingBetaInputMessage_Content as a PromptCachingBetaInputMessageContent1
func (t PromptCachingBetaInputMessage_Content) AsPromptCachingBetaInputMessageContent1() (PromptCachingBetaInputMessageContent1, error) {
	var body PromptCachingBetaInputMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaInputMessageContent1 overwrites any union data inside the PromptCachingBetaInputMessage_Content as the provided PromptCachingBetaInputMessageContent1
func (t *PromptCachingBetaInputMessage_Content) FromPromptCachingBetaInputMessageContent1(v PromptCachingBetaInputMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaInputMessageContent1 performs a merge with any union data inside the PromptCachingBetaInputMessage_Content, using the provided PromptCachingBetaInputMessageContent1
func (t *PromptCachingBetaInputMessage_Content) MergePromptCachingBetaInputMessageContent1(v PromptCachingBetaInputMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaInputMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaInputMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaMessageStopReason0 returns the union data inside the PromptCachingBetaMessage_StopReason as a PromptCachingBetaMessageStopReason0
func (t PromptCachingBetaMessage_StopReason) AsPromptCachingBetaMessageStopReason0() (PromptCachingBetaMessageStopReason0, error) {
	var body PromptCachingBetaMessageStopReason0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaMessageStopReason0 overwrites any union data inside the PromptCachingBetaMessage_StopReason as the provided PromptCachingBetaMessageStopReason0
func (t *PromptCachingBetaMessage_StopReason) FromPromptCachingBetaMessageStopReason0(v PromptCachingBetaMessageStopReason0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaMessageStopReason0 performs a merge with any union data inside the PromptCachingBetaMessage_StopReason, using the provided PromptCachingBetaMessageStopReason0
func (t *PromptCachingBetaMessage_StopReason) MergePromptCachingBetaMessageStopReason0(v PromptCachingBetaMessageStopReason0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaMessage_StopReason) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaMessage_StopReason) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaMessageStopSequence0 returns the union data inside the PromptCachingBetaMessage_StopSequence as a PromptCachingBetaMessageStopSequence0
func (t PromptCachingBetaMessage_StopSequence) AsPromptCachingBetaMessageStopSequence0() (PromptCachingBetaMessageStopSequence0, error) {
	var body PromptCachingBetaMessageStopSequence0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaMessageStopSequence0 overwrites any union data inside the PromptCachingBetaMessage_StopSequence as the provided PromptCachingBetaMessageStopSequence0
func (t *PromptCachingBetaMessage_StopSequence) FromPromptCachingBetaMessageStopSequence0(v PromptCachingBetaMessageStopSequence0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaMessageStopSequence0 performs a merge with any union data inside the PromptCachingBetaMessage_StopSequence, using the provided PromptCachingBetaMessageStopSequence0
func (t *PromptCachingBetaMessage_StopSequence) MergePromptCachingBetaMessageStopSequence0(v PromptCachingBetaMessageStopSequence0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaMessage_StopSequence) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaMessage_StopSequence) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCacheControlEphemeral returns the union data inside the PromptCachingBetaRequestImageBlockCacheControl0 as a CacheControlEphemeral
func (t PromptCachingBetaRequestImageBlockCacheControl0) AsCacheControlEphemeral() (CacheControlEphemeral, error) {
	var body CacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCacheControlEphemeral overwrites any union data inside the PromptCachingBetaRequestImageBlockCacheControl0 as the provided CacheControlEphemeral
func (t *PromptCachingBetaRequestImageBlockCacheControl0) FromCacheControlEphemeral(v CacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCacheControlEphemeral performs a merge with any union data inside the PromptCachingBetaRequestImageBlockCacheControl0, using the provided CacheControlEphemeral
func (t *PromptCachingBetaRequestImageBlockCacheControl0) MergeCacheControlEphemeral(v CacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestImageBlockCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromptCachingBetaRequestImageBlockCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromptCachingBetaRequestImageBlockCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestImageBlockCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaRequestImageBlockCacheControl0 returns the union data inside the PromptCachingBetaRequestImageBlock_CacheControl as a PromptCachingBetaRequestImageBlockCacheControl0
func (t PromptCachingBetaRequestImageBlock_CacheControl) AsPromptCachingBetaRequestImageBlockCacheControl0() (PromptCachingBetaRequestImageBlockCacheControl0, error) {
	var body PromptCachingBetaRequestImageBlockCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestImageBlockCacheControl0 overwrites any union data inside the PromptCachingBetaRequestImageBlock_CacheControl as the provided PromptCachingBetaRequestImageBlockCacheControl0
func (t *PromptCachingBetaRequestImageBlock_CacheControl) FromPromptCachingBetaRequestImageBlockCacheControl0(v PromptCachingBetaRequestImageBlockCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestImageBlockCacheControl0 performs a merge with any union data inside the PromptCachingBetaRequestImageBlock_CacheControl, using the provided PromptCachingBetaRequestImageBlockCacheControl0
func (t *PromptCachingBetaRequestImageBlock_CacheControl) MergePromptCachingBetaRequestImageBlockCacheControl0(v PromptCachingBetaRequestImageBlockCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestImageBlock_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestImageBlock_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBase64ImageSource returns the union data inside the PromptCachingBetaRequestImageBlock_Source as a Base64ImageSource
func (t PromptCachingBetaRequestImageBlock_Source) AsBase64ImageSource() (Base64ImageSource, error) {
	var body Base64ImageSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBase64ImageSource overwrites any union data inside the PromptCachingBetaRequestImageBlock_Source as the provided Base64ImageSource
func (t *PromptCachingBetaRequestImageBlock_Source) FromBase64ImageSource(v Base64ImageSource) error {
	v.Type = "base64"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBase64ImageSource performs a merge with any union data inside the PromptCachingBetaRequestImageBlock_Source, using the provided Base64ImageSource
func (t *PromptCachingBetaRequestImageBlock_Source) MergeBase64ImageSource(v Base64ImageSource) error {
	v.Type = "base64"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestImageBlock_Source) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromptCachingBetaRequestImageBlock_Source) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "base64":
		return t.AsBase64ImageSource()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromptCachingBetaRequestImageBlock_Source) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestImageBlock_Source) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCacheControlEphemeral returns the union data inside the PromptCachingBetaRequestTextBlockCacheControl0 as a CacheControlEphemeral
func (t PromptCachingBetaRequestTextBlockCacheControl0) AsCacheControlEphemeral() (CacheControlEphemeral, error) {
	var body CacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCacheControlEphemeral overwrites any union data inside the PromptCachingBetaRequestTextBlockCacheControl0 as the provided CacheControlEphemeral
func (t *PromptCachingBetaRequestTextBlockCacheControl0) FromCacheControlEphemeral(v CacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCacheControlEphemeral performs a merge with any union data inside the PromptCachingBetaRequestTextBlockCacheControl0, using the provided CacheControlEphemeral
func (t *PromptCachingBetaRequestTextBlockCacheControl0) MergeCacheControlEphemeral(v CacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestTextBlockCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromptCachingBetaRequestTextBlockCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromptCachingBetaRequestTextBlockCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestTextBlockCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaRequestTextBlockCacheControl0 returns the union data inside the PromptCachingBetaRequestTextBlock_CacheControl as a PromptCachingBetaRequestTextBlockCacheControl0
func (t PromptCachingBetaRequestTextBlock_CacheControl) AsPromptCachingBetaRequestTextBlockCacheControl0() (PromptCachingBetaRequestTextBlockCacheControl0, error) {
	var body PromptCachingBetaRequestTextBlockCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestTextBlockCacheControl0 overwrites any union data inside the PromptCachingBetaRequestTextBlock_CacheControl as the provided PromptCachingBetaRequestTextBlockCacheControl0
func (t *PromptCachingBetaRequestTextBlock_CacheControl) FromPromptCachingBetaRequestTextBlockCacheControl0(v PromptCachingBetaRequestTextBlockCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestTextBlockCacheControl0 performs a merge with any union data inside the PromptCachingBetaRequestTextBlock_CacheControl, using the provided PromptCachingBetaRequestTextBlockCacheControl0
func (t *PromptCachingBetaRequestTextBlock_CacheControl) MergePromptCachingBetaRequestTextBlockCacheControl0(v PromptCachingBetaRequestTextBlockCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestTextBlock_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestTextBlock_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCacheControlEphemeral returns the union data inside the PromptCachingBetaRequestToolResultBlockCacheControl0 as a CacheControlEphemeral
func (t PromptCachingBetaRequestToolResultBlockCacheControl0) AsCacheControlEphemeral() (CacheControlEphemeral, error) {
	var body CacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCacheControlEphemeral overwrites any union data inside the PromptCachingBetaRequestToolResultBlockCacheControl0 as the provided CacheControlEphemeral
func (t *PromptCachingBetaRequestToolResultBlockCacheControl0) FromCacheControlEphemeral(v CacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCacheControlEphemeral performs a merge with any union data inside the PromptCachingBetaRequestToolResultBlockCacheControl0, using the provided CacheControlEphemeral
func (t *PromptCachingBetaRequestToolResultBlockCacheControl0) MergeCacheControlEphemeral(v CacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestToolResultBlockCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromptCachingBetaRequestToolResultBlockCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromptCachingBetaRequestToolResultBlockCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestToolResultBlockCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaRequestToolResultBlockCacheControl0 returns the union data inside the PromptCachingBetaRequestToolResultBlock_CacheControl as a PromptCachingBetaRequestToolResultBlockCacheControl0
func (t PromptCachingBetaRequestToolResultBlock_CacheControl) AsPromptCachingBetaRequestToolResultBlockCacheControl0() (PromptCachingBetaRequestToolResultBlockCacheControl0, error) {
	var body PromptCachingBetaRequestToolResultBlockCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestToolResultBlockCacheControl0 overwrites any union data inside the PromptCachingBetaRequestToolResultBlock_CacheControl as the provided PromptCachingBetaRequestToolResultBlockCacheControl0
func (t *PromptCachingBetaRequestToolResultBlock_CacheControl) FromPromptCachingBetaRequestToolResultBlockCacheControl0(v PromptCachingBetaRequestToolResultBlockCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestToolResultBlockCacheControl0 performs a merge with any union data inside the PromptCachingBetaRequestToolResultBlock_CacheControl, using the provided PromptCachingBetaRequestToolResultBlockCacheControl0
func (t *PromptCachingBetaRequestToolResultBlock_CacheControl) MergePromptCachingBetaRequestToolResultBlockCacheControl0(v PromptCachingBetaRequestToolResultBlockCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestToolResultBlock_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestToolResultBlock_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaRequestTextBlock returns the union data inside the PromptCachingBetaRequestToolResultBlock_Content_1_Item as a PromptCachingBetaRequestTextBlock
func (t PromptCachingBetaRequestToolResultBlock_Content_1_Item) AsPromptCachingBetaRequestTextBlock() (PromptCachingBetaRequestTextBlock, error) {
	var body PromptCachingBetaRequestTextBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestTextBlock overwrites any union data inside the PromptCachingBetaRequestToolResultBlock_Content_1_Item as the provided PromptCachingBetaRequestTextBlock
func (t *PromptCachingBetaRequestToolResultBlock_Content_1_Item) FromPromptCachingBetaRequestTextBlock(v PromptCachingBetaRequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestTextBlock performs a merge with any union data inside the PromptCachingBetaRequestToolResultBlock_Content_1_Item, using the provided PromptCachingBetaRequestTextBlock
func (t *PromptCachingBetaRequestToolResultBlock_Content_1_Item) MergePromptCachingBetaRequestTextBlock(v PromptCachingBetaRequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromptCachingBetaRequestImageBlock returns the union data inside the PromptCachingBetaRequestToolResultBlock_Content_1_Item as a PromptCachingBetaRequestImageBlock
func (t PromptCachingBetaRequestToolResultBlock_Content_1_Item) AsPromptCachingBetaRequestImageBlock() (PromptCachingBetaRequestImageBlock, error) {
	var body PromptCachingBetaRequestImageBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestImageBlock overwrites any union data inside the PromptCachingBetaRequestToolResultBlock_Content_1_Item as the provided PromptCachingBetaRequestImageBlock
func (t *PromptCachingBetaRequestToolResultBlock_Content_1_Item) FromPromptCachingBetaRequestImageBlock(v PromptCachingBetaRequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestImageBlock performs a merge with any union data inside the PromptCachingBetaRequestToolResultBlock_Content_1_Item, using the provided PromptCachingBetaRequestImageBlock
func (t *PromptCachingBetaRequestToolResultBlock_Content_1_Item) MergePromptCachingBetaRequestImageBlock(v PromptCachingBetaRequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestToolResultBlock_Content_1_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromptCachingBetaRequestToolResultBlock_Content_1_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "image":
		return t.AsPromptCachingBetaRequestImageBlock()
	case "text":
		return t.AsPromptCachingBetaRequestTextBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromptCachingBetaRequestToolResultBlock_Content_1_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestToolResultBlock_Content_1_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaRequestToolResultBlockContent0 returns the union data inside the PromptCachingBetaRequestToolResultBlock_Content as a PromptCachingBetaRequestToolResultBlockContent0
func (t PromptCachingBetaRequestToolResultBlock_Content) AsPromptCachingBetaRequestToolResultBlockContent0() (PromptCachingBetaRequestToolResultBlockContent0, error) {
	var body PromptCachingBetaRequestToolResultBlockContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestToolResultBlockContent0 overwrites any union data inside the PromptCachingBetaRequestToolResultBlock_Content as the provided PromptCachingBetaRequestToolResultBlockContent0
func (t *PromptCachingBetaRequestToolResultBlock_Content) FromPromptCachingBetaRequestToolResultBlockContent0(v PromptCachingBetaRequestToolResultBlockContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestToolResultBlockContent0 performs a merge with any union data inside the PromptCachingBetaRequestToolResultBlock_Content, using the provided PromptCachingBetaRequestToolResultBlockContent0
func (t *PromptCachingBetaRequestToolResultBlock_Content) MergePromptCachingBetaRequestToolResultBlockContent0(v PromptCachingBetaRequestToolResultBlockContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromptCachingBetaRequestToolResultBlockContent1 returns the union data inside the PromptCachingBetaRequestToolResultBlock_Content as a PromptCachingBetaRequestToolResultBlockContent1
func (t PromptCachingBetaRequestToolResultBlock_Content) AsPromptCachingBetaRequestToolResultBlockContent1() (PromptCachingBetaRequestToolResultBlockContent1, error) {
	var body PromptCachingBetaRequestToolResultBlockContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestToolResultBlockContent1 overwrites any union data inside the PromptCachingBetaRequestToolResultBlock_Content as the provided PromptCachingBetaRequestToolResultBlockContent1
func (t *PromptCachingBetaRequestToolResultBlock_Content) FromPromptCachingBetaRequestToolResultBlockContent1(v PromptCachingBetaRequestToolResultBlockContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestToolResultBlockContent1 performs a merge with any union data inside the PromptCachingBetaRequestToolResultBlock_Content, using the provided PromptCachingBetaRequestToolResultBlockContent1
func (t *PromptCachingBetaRequestToolResultBlock_Content) MergePromptCachingBetaRequestToolResultBlockContent1(v PromptCachingBetaRequestToolResultBlockContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestToolResultBlock_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestToolResultBlock_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCacheControlEphemeral returns the union data inside the PromptCachingBetaRequestToolUseBlockCacheControl0 as a CacheControlEphemeral
func (t PromptCachingBetaRequestToolUseBlockCacheControl0) AsCacheControlEphemeral() (CacheControlEphemeral, error) {
	var body CacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCacheControlEphemeral overwrites any union data inside the PromptCachingBetaRequestToolUseBlockCacheControl0 as the provided CacheControlEphemeral
func (t *PromptCachingBetaRequestToolUseBlockCacheControl0) FromCacheControlEphemeral(v CacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCacheControlEphemeral performs a merge with any union data inside the PromptCachingBetaRequestToolUseBlockCacheControl0, using the provided CacheControlEphemeral
func (t *PromptCachingBetaRequestToolUseBlockCacheControl0) MergeCacheControlEphemeral(v CacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestToolUseBlockCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromptCachingBetaRequestToolUseBlockCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromptCachingBetaRequestToolUseBlockCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestToolUseBlockCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaRequestToolUseBlockCacheControl0 returns the union data inside the PromptCachingBetaRequestToolUseBlock_CacheControl as a PromptCachingBetaRequestToolUseBlockCacheControl0
func (t PromptCachingBetaRequestToolUseBlock_CacheControl) AsPromptCachingBetaRequestToolUseBlockCacheControl0() (PromptCachingBetaRequestToolUseBlockCacheControl0, error) {
	var body PromptCachingBetaRequestToolUseBlockCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaRequestToolUseBlockCacheControl0 overwrites any union data inside the PromptCachingBetaRequestToolUseBlock_CacheControl as the provided PromptCachingBetaRequestToolUseBlockCacheControl0
func (t *PromptCachingBetaRequestToolUseBlock_CacheControl) FromPromptCachingBetaRequestToolUseBlockCacheControl0(v PromptCachingBetaRequestToolUseBlockCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaRequestToolUseBlockCacheControl0 performs a merge with any union data inside the PromptCachingBetaRequestToolUseBlock_CacheControl, using the provided PromptCachingBetaRequestToolUseBlockCacheControl0
func (t *PromptCachingBetaRequestToolUseBlock_CacheControl) MergePromptCachingBetaRequestToolUseBlockCacheControl0(v PromptCachingBetaRequestToolUseBlockCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaRequestToolUseBlock_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaRequestToolUseBlock_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCacheControlEphemeral returns the union data inside the PromptCachingBetaToolCacheControl0 as a CacheControlEphemeral
func (t PromptCachingBetaToolCacheControl0) AsCacheControlEphemeral() (CacheControlEphemeral, error) {
	var body CacheControlEphemeral
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCacheControlEphemeral overwrites any union data inside the PromptCachingBetaToolCacheControl0 as the provided CacheControlEphemeral
func (t *PromptCachingBetaToolCacheControl0) FromCacheControlEphemeral(v CacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCacheControlEphemeral performs a merge with any union data inside the PromptCachingBetaToolCacheControl0, using the provided CacheControlEphemeral
func (t *PromptCachingBetaToolCacheControl0) MergeCacheControlEphemeral(v CacheControlEphemeral) error {
	v.Type = "ephemeral"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaToolCacheControl0) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromptCachingBetaToolCacheControl0) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ephemeral":
		return t.AsCacheControlEphemeral()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromptCachingBetaToolCacheControl0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaToolCacheControl0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaToolCacheControl0 returns the union data inside the PromptCachingBetaTool_CacheControl as a PromptCachingBetaToolCacheControl0
func (t PromptCachingBetaTool_CacheControl) AsPromptCachingBetaToolCacheControl0() (PromptCachingBetaToolCacheControl0, error) {
	var body PromptCachingBetaToolCacheControl0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaToolCacheControl0 overwrites any union data inside the PromptCachingBetaTool_CacheControl as the provided PromptCachingBetaToolCacheControl0
func (t *PromptCachingBetaTool_CacheControl) FromPromptCachingBetaToolCacheControl0(v PromptCachingBetaToolCacheControl0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaToolCacheControl0 performs a merge with any union data inside the PromptCachingBetaTool_CacheControl, using the provided PromptCachingBetaToolCacheControl0
func (t *PromptCachingBetaTool_CacheControl) MergePromptCachingBetaToolCacheControl0(v PromptCachingBetaToolCacheControl0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaTool_CacheControl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaTool_CacheControl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaUsageCacheCreationInputTokens0 returns the union data inside the PromptCachingBetaUsage_CacheCreationInputTokens as a PromptCachingBetaUsageCacheCreationInputTokens0
func (t PromptCachingBetaUsage_CacheCreationInputTokens) AsPromptCachingBetaUsageCacheCreationInputTokens0() (PromptCachingBetaUsageCacheCreationInputTokens0, error) {
	var body PromptCachingBetaUsageCacheCreationInputTokens0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaUsageCacheCreationInputTokens0 overwrites any union data inside the PromptCachingBetaUsage_CacheCreationInputTokens as the provided PromptCachingBetaUsageCacheCreationInputTokens0
func (t *PromptCachingBetaUsage_CacheCreationInputTokens) FromPromptCachingBetaUsageCacheCreationInputTokens0(v PromptCachingBetaUsageCacheCreationInputTokens0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaUsageCacheCreationInputTokens0 performs a merge with any union data inside the PromptCachingBetaUsage_CacheCreationInputTokens, using the provided PromptCachingBetaUsageCacheCreationInputTokens0
func (t *PromptCachingBetaUsage_CacheCreationInputTokens) MergePromptCachingBetaUsageCacheCreationInputTokens0(v PromptCachingBetaUsageCacheCreationInputTokens0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaUsage_CacheCreationInputTokens) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaUsage_CacheCreationInputTokens) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromptCachingBetaUsageCacheReadInputTokens0 returns the union data inside the PromptCachingBetaUsage_CacheReadInputTokens as a PromptCachingBetaUsageCacheReadInputTokens0
func (t PromptCachingBetaUsage_CacheReadInputTokens) AsPromptCachingBetaUsageCacheReadInputTokens0() (PromptCachingBetaUsageCacheReadInputTokens0, error) {
	var body PromptCachingBetaUsageCacheReadInputTokens0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromptCachingBetaUsageCacheReadInputTokens0 overwrites any union data inside the PromptCachingBetaUsage_CacheReadInputTokens as the provided PromptCachingBetaUsageCacheReadInputTokens0
func (t *PromptCachingBetaUsage_CacheReadInputTokens) FromPromptCachingBetaUsageCacheReadInputTokens0(v PromptCachingBetaUsageCacheReadInputTokens0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromptCachingBetaUsageCacheReadInputTokens0 performs a merge with any union data inside the PromptCachingBetaUsage_CacheReadInputTokens, using the provided PromptCachingBetaUsageCacheReadInputTokens0
func (t *PromptCachingBetaUsage_CacheReadInputTokens) MergePromptCachingBetaUsageCacheReadInputTokens0(v PromptCachingBetaUsageCacheReadInputTokens0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromptCachingBetaUsage_CacheReadInputTokens) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromptCachingBetaUsage_CacheReadInputTokens) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBase64ImageSource returns the union data inside the RequestImageBlock_Source as a Base64ImageSource
func (t RequestImageBlock_Source) AsBase64ImageSource() (Base64ImageSource, error) {
	var body Base64ImageSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBase64ImageSource overwrites any union data inside the RequestImageBlock_Source as the provided Base64ImageSource
func (t *RequestImageBlock_Source) FromBase64ImageSource(v Base64ImageSource) error {
	v.Type = "base64"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBase64ImageSource performs a merge with any union data inside the RequestImageBlock_Source, using the provided Base64ImageSource
func (t *RequestImageBlock_Source) MergeBase64ImageSource(v Base64ImageSource) error {
	v.Type = "base64"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestImageBlock_Source) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RequestImageBlock_Source) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "base64":
		return t.AsBase64ImageSource()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RequestImageBlock_Source) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestImageBlock_Source) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRequestTextBlock returns the union data inside the RequestToolResultBlock_Content_1_Item as a RequestTextBlock
func (t RequestToolResultBlock_Content_1_Item) AsRequestTextBlock() (RequestTextBlock, error) {
	var body RequestTextBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestTextBlock overwrites any union data inside the RequestToolResultBlock_Content_1_Item as the provided RequestTextBlock
func (t *RequestToolResultBlock_Content_1_Item) FromRequestTextBlock(v RequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestTextBlock performs a merge with any union data inside the RequestToolResultBlock_Content_1_Item, using the provided RequestTextBlock
func (t *RequestToolResultBlock_Content_1_Item) MergeRequestTextBlock(v RequestTextBlock) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestImageBlock returns the union data inside the RequestToolResultBlock_Content_1_Item as a RequestImageBlock
func (t RequestToolResultBlock_Content_1_Item) AsRequestImageBlock() (RequestImageBlock, error) {
	var body RequestImageBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestImageBlock overwrites any union data inside the RequestToolResultBlock_Content_1_Item as the provided RequestImageBlock
func (t *RequestToolResultBlock_Content_1_Item) FromRequestImageBlock(v RequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestImageBlock performs a merge with any union data inside the RequestToolResultBlock_Content_1_Item, using the provided RequestImageBlock
func (t *RequestToolResultBlock_Content_1_Item) MergeRequestImageBlock(v RequestImageBlock) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestToolResultBlock_Content_1_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RequestToolResultBlock_Content_1_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "image":
		return t.AsRequestImageBlock()
	case "text":
		return t.AsRequestTextBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RequestToolResultBlock_Content_1_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestToolResultBlock_Content_1_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRequestToolResultBlockContent0 returns the union data inside the RequestToolResultBlock_Content as a RequestToolResultBlockContent0
func (t RequestToolResultBlock_Content) AsRequestToolResultBlockContent0() (RequestToolResultBlockContent0, error) {
	var body RequestToolResultBlockContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestToolResultBlockContent0 overwrites any union data inside the RequestToolResultBlock_Content as the provided RequestToolResultBlockContent0
func (t *RequestToolResultBlock_Content) FromRequestToolResultBlockContent0(v RequestToolResultBlockContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestToolResultBlockContent0 performs a merge with any union data inside the RequestToolResultBlock_Content, using the provided RequestToolResultBlockContent0
func (t *RequestToolResultBlock_Content) MergeRequestToolResultBlockContent0(v RequestToolResultBlockContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestToolResultBlockContent1 returns the union data inside the RequestToolResultBlock_Content as a RequestToolResultBlockContent1
func (t RequestToolResultBlock_Content) AsRequestToolResultBlockContent1() (RequestToolResultBlockContent1, error) {
	var body RequestToolResultBlockContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestToolResultBlockContent1 overwrites any union data inside the RequestToolResultBlock_Content as the provided RequestToolResultBlockContent1
func (t *RequestToolResultBlock_Content) FromRequestToolResultBlockContent1(v RequestToolResultBlockContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestToolResultBlockContent1 performs a merge with any union data inside the RequestToolResultBlock_Content, using the provided RequestToolResultBlockContent1
func (t *RequestToolResultBlock_Content) MergeRequestToolResultBlockContent1(v RequestToolResultBlockContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestToolResultBlock_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestToolResultBlock_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsToolChoiceAuto returns the union data inside the ToolChoice as a ToolChoiceAuto
func (t ToolChoice) AsToolChoiceAuto() (ToolChoiceAuto, error) {
	var body ToolChoiceAuto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoiceAuto overwrites any union data inside the ToolChoice as the provided ToolChoiceAuto
func (t *ToolChoice) FromToolChoiceAuto(v ToolChoiceAuto) error {
	v.Type = "auto"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoiceAuto performs a merge with any union data inside the ToolChoice, using the provided ToolChoiceAuto
func (t *ToolChoice) MergeToolChoiceAuto(v ToolChoiceAuto) error {
	v.Type = "auto"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsToolChoiceAny returns the union data inside the ToolChoice as a ToolChoiceAny
func (t ToolChoice) AsToolChoiceAny() (ToolChoiceAny, error) {
	var body ToolChoiceAny
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoiceAny overwrites any union data inside the ToolChoice as the provided ToolChoiceAny
func (t *ToolChoice) FromToolChoiceAny(v ToolChoiceAny) error {
	v.Type = "any"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoiceAny performs a merge with any union data inside the ToolChoice, using the provided ToolChoiceAny
func (t *ToolChoice) MergeToolChoiceAny(v ToolChoiceAny) error {
	v.Type = "any"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsToolChoiceTool returns the union data inside the ToolChoice as a ToolChoiceTool
func (t ToolChoice) AsToolChoiceTool() (ToolChoiceTool, error) {
	var body ToolChoiceTool
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoiceTool overwrites any union data inside the ToolChoice as the provided ToolChoiceTool
func (t *ToolChoice) FromToolChoiceTool(v ToolChoiceTool) error {
	v.Type = "tool"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoiceTool performs a merge with any union data inside the ToolChoice, using the provided ToolChoiceTool
func (t *ToolChoice) MergeToolChoiceTool(v ToolChoiceTool) error {
	v.Type = "tool"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ToolChoice) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ToolChoice) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "any":
		return t.AsToolChoiceAny()
	case "auto":
		return t.AsToolChoiceAuto()
	case "tool":
		return t.AsToolChoiceTool()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ToolChoice) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ToolChoice) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CompletePostWithBody request with any body
	CompletePostWithBody(ctx context.Context, params *CompletePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompletePost(ctx context.Context, params *CompletePostParams, body CompletePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MessagesPostWithBody request with any body
	MessagesPostWithBody(ctx context.Context, params *MessagesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MessagesPost(ctx context.Context, params *MessagesPostParams, body MessagesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BetaMessageBatchesList request
	BetaMessageBatchesList(ctx context.Context, params *BetaMessageBatchesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BetaMessageBatchesPostWithBody request with any body
	BetaMessageBatchesPostWithBody(ctx context.Context, params *BetaMessageBatchesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BetaMessageBatchesPost(ctx context.Context, params *BetaMessageBatchesPostParams, body BetaMessageBatchesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BetaMessageBatchesRetrieve request
	BetaMessageBatchesRetrieve(ctx context.Context, messageBatchId string, params *BetaMessageBatchesRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BetaMessageBatchesCancel request
	BetaMessageBatchesCancel(ctx context.Context, messageBatchId string, params *BetaMessageBatchesCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BetaMessageBatchesResults request
	BetaMessageBatchesResults(ctx context.Context, messageBatchId string, params *BetaMessageBatchesResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BetaMessagesCountTokensPostWithBody request with any body
	BetaMessagesCountTokensPostWithBody(ctx context.Context, params *BetaMessagesCountTokensPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BetaMessagesCountTokensPost(ctx context.Context, params *BetaMessagesCountTokensPostParams, body BetaMessagesCountTokensPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromptCachingBetaMessagesPostWithBody request with any body
	PromptCachingBetaMessagesPostWithBody(ctx context.Context, params *PromptCachingBetaMessagesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PromptCachingBetaMessagesPost(ctx context.Context, params *PromptCachingBetaMessagesPostParams, body PromptCachingBetaMessagesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CompletePostWithBody(ctx context.Context, params *CompletePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompletePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompletePost(ctx context.Context, params *CompletePostParams, body CompletePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompletePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MessagesPostWithBody(ctx context.Context, params *MessagesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMessagesPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MessagesPost(ctx context.Context, params *MessagesPostParams, body MessagesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMessagesPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BetaMessageBatchesList(ctx context.Context, params *BetaMessageBatchesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBetaMessageBatchesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BetaMessageBatchesPostWithBody(ctx context.Context, params *BetaMessageBatchesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBetaMessageBatchesPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BetaMessageBatchesPost(ctx context.Context, params *BetaMessageBatchesPostParams, body BetaMessageBatchesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBetaMessageBatchesPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BetaMessageBatchesRetrieve(ctx context.Context, messageBatchId string, params *BetaMessageBatchesRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBetaMessageBatchesRetrieveRequest(c.Server, messageBatchId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BetaMessageBatchesCancel(ctx context.Context, messageBatchId string, params *BetaMessageBatchesCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBetaMessageBatchesCancelRequest(c.Server, messageBatchId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BetaMessageBatchesResults(ctx context.Context, messageBatchId string, params *BetaMessageBatchesResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBetaMessageBatchesResultsRequest(c.Server, messageBatchId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BetaMessagesCountTokensPostWithBody(ctx context.Context, params *BetaMessagesCountTokensPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBetaMessagesCountTokensPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BetaMessagesCountTokensPost(ctx context.Context, params *BetaMessagesCountTokensPostParams, body BetaMessagesCountTokensPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBetaMessagesCountTokensPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptCachingBetaMessagesPostWithBody(ctx context.Context, params *PromptCachingBetaMessagesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptCachingBetaMessagesPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptCachingBetaMessagesPost(ctx context.Context, params *PromptCachingBetaMessagesPostParams, body PromptCachingBetaMessagesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptCachingBetaMessagesPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCompletePostRequest calls the generic CompletePost builder with application/json body
func NewCompletePostRequest(server string, params *CompletePostParams, body CompletePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompletePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCompletePostRequestWithBody generates requests for CompletePost with any type of body
func NewCompletePostRequestWithBody(server string, params *CompletePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/complete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AnthropicVersion != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "anthropic-version", runtime.ParamLocationHeader, *params.AnthropicVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-version", headerParam0)
		}

		if params.XApiKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam1)
		}

	}

	return req, nil
}

// NewMessagesPostRequest calls the generic MessagesPost builder with application/json body
func NewMessagesPostRequest(server string, params *MessagesPostParams, body MessagesPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMessagesPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMessagesPostRequestWithBody generates requests for MessagesPost with any type of body
func NewMessagesPostRequestWithBody(server string, params *MessagesPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AnthropicVersion != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "anthropic-version", runtime.ParamLocationHeader, *params.AnthropicVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-version", headerParam0)
		}

		if params.XApiKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam1)
		}

	}

	return req, nil
}

// NewBetaMessageBatchesListRequest generates requests for BetaMessageBatchesList
func NewBetaMessageBatchesListRequest(server string, params *BetaMessageBatchesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/messages/batches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BeforeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_id", runtime.ParamLocationQuery, *params.BeforeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AfterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after_id", runtime.ParamLocationQuery, *params.AfterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AnthropicBeta != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "anthropic-beta", runtime.ParamLocationHeader, *params.AnthropicBeta)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-beta", headerParam0)
		}

		if params.AnthropicVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "anthropic-version", runtime.ParamLocationHeader, *params.AnthropicVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-version", headerParam1)
		}

		if params.XApiKey != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam2)
		}

	}

	return req, nil
}

// NewBetaMessageBatchesPostRequest calls the generic BetaMessageBatchesPost builder with application/json body
func NewBetaMessageBatchesPostRequest(server string, params *BetaMessageBatchesPostParams, body BetaMessageBatchesPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaMessageBatchesPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewBetaMessageBatchesPostRequestWithBody generates requests for BetaMessageBatchesPost with any type of body
func NewBetaMessageBatchesPostRequestWithBody(server string, params *BetaMessageBatchesPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/messages/batches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AnthropicBeta != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "anthropic-beta", runtime.ParamLocationHeader, *params.AnthropicBeta)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-beta", headerParam0)
		}

		if params.AnthropicVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "anthropic-version", runtime.ParamLocationHeader, *params.AnthropicVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-version", headerParam1)
		}

		if params.XApiKey != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam2)
		}

	}

	return req, nil
}

// NewBetaMessageBatchesRetrieveRequest generates requests for BetaMessageBatchesRetrieve
func NewBetaMessageBatchesRetrieveRequest(server string, messageBatchId string, params *BetaMessageBatchesRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "message_batch_id", runtime.ParamLocationPath, messageBatchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/messages/batches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AnthropicBeta != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "anthropic-beta", runtime.ParamLocationHeader, *params.AnthropicBeta)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-beta", headerParam0)
		}

		if params.AnthropicVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "anthropic-version", runtime.ParamLocationHeader, *params.AnthropicVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-version", headerParam1)
		}

		if params.XApiKey != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam2)
		}

	}

	return req, nil
}

// NewBetaMessageBatchesCancelRequest generates requests for BetaMessageBatchesCancel
func NewBetaMessageBatchesCancelRequest(server string, messageBatchId string, params *BetaMessageBatchesCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "message_batch_id", runtime.ParamLocationPath, messageBatchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/messages/batches/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AnthropicBeta != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "anthropic-beta", runtime.ParamLocationHeader, *params.AnthropicBeta)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-beta", headerParam0)
		}

		if params.AnthropicVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "anthropic-version", runtime.ParamLocationHeader, *params.AnthropicVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-version", headerParam1)
		}

		if params.XApiKey != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam2)
		}

	}

	return req, nil
}

// NewBetaMessageBatchesResultsRequest generates requests for BetaMessageBatchesResults
func NewBetaMessageBatchesResultsRequest(server string, messageBatchId string, params *BetaMessageBatchesResultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "message_batch_id", runtime.ParamLocationPath, messageBatchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/messages/batches/%s/results", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AnthropicBeta != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "anthropic-beta", runtime.ParamLocationHeader, *params.AnthropicBeta)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-beta", headerParam0)
		}

		if params.AnthropicVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "anthropic-version", runtime.ParamLocationHeader, *params.AnthropicVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-version", headerParam1)
		}

		if params.XApiKey != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam2)
		}

	}

	return req, nil
}

// NewBetaMessagesCountTokensPostRequest calls the generic BetaMessagesCountTokensPost builder with application/json body
func NewBetaMessagesCountTokensPostRequest(server string, params *BetaMessagesCountTokensPostParams, body BetaMessagesCountTokensPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaMessagesCountTokensPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewBetaMessagesCountTokensPostRequestWithBody generates requests for BetaMessagesCountTokensPost with any type of body
func NewBetaMessagesCountTokensPostRequestWithBody(server string, params *BetaMessagesCountTokensPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/messages/count_tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AnthropicBeta != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "anthropic-beta", runtime.ParamLocationHeader, *params.AnthropicBeta)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-beta", headerParam0)
		}

		if params.AnthropicVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "anthropic-version", runtime.ParamLocationHeader, *params.AnthropicVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-version", headerParam1)
		}

		if params.XApiKey != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam2)
		}

	}

	return req, nil
}

// NewPromptCachingBetaMessagesPostRequest calls the generic PromptCachingBetaMessagesPost builder with application/json body
func NewPromptCachingBetaMessagesPostRequest(server string, params *PromptCachingBetaMessagesPostParams, body PromptCachingBetaMessagesPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPromptCachingBetaMessagesPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPromptCachingBetaMessagesPostRequestWithBody generates requests for PromptCachingBetaMessagesPost with any type of body
func NewPromptCachingBetaMessagesPostRequestWithBody(server string, params *PromptCachingBetaMessagesPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/messages?beta=prompt_caching")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AnthropicBeta != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "anthropic-beta", runtime.ParamLocationHeader, *params.AnthropicBeta)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-beta", headerParam0)
		}

		if params.AnthropicVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "anthropic-version", runtime.ParamLocationHeader, *params.AnthropicVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("anthropic-version", headerParam1)
		}

		if params.XApiKey != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam2)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CompletePostWithBodyWithResponse request with any body
	CompletePostWithBodyWithResponse(ctx context.Context, params *CompletePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompletePostResponse, error)

	CompletePostWithResponse(ctx context.Context, params *CompletePostParams, body CompletePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CompletePostResponse, error)

	// MessagesPostWithBodyWithResponse request with any body
	MessagesPostWithBodyWithResponse(ctx context.Context, params *MessagesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MessagesPostResponse, error)

	MessagesPostWithResponse(ctx context.Context, params *MessagesPostParams, body MessagesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MessagesPostResponse, error)

	// BetaMessageBatchesListWithResponse request
	BetaMessageBatchesListWithResponse(ctx context.Context, params *BetaMessageBatchesListParams, reqEditors ...RequestEditorFn) (*BetaMessageBatchesListResponse, error)

	// BetaMessageBatchesPostWithBodyWithResponse request with any body
	BetaMessageBatchesPostWithBodyWithResponse(ctx context.Context, params *BetaMessageBatchesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BetaMessageBatchesPostResponse, error)

	BetaMessageBatchesPostWithResponse(ctx context.Context, params *BetaMessageBatchesPostParams, body BetaMessageBatchesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*BetaMessageBatchesPostResponse, error)

	// BetaMessageBatchesRetrieveWithResponse request
	BetaMessageBatchesRetrieveWithResponse(ctx context.Context, messageBatchId string, params *BetaMessageBatchesRetrieveParams, reqEditors ...RequestEditorFn) (*BetaMessageBatchesRetrieveResponse, error)

	// BetaMessageBatchesCancelWithResponse request
	BetaMessageBatchesCancelWithResponse(ctx context.Context, messageBatchId string, params *BetaMessageBatchesCancelParams, reqEditors ...RequestEditorFn) (*BetaMessageBatchesCancelResponse, error)

	// BetaMessageBatchesResultsWithResponse request
	BetaMessageBatchesResultsWithResponse(ctx context.Context, messageBatchId string, params *BetaMessageBatchesResultsParams, reqEditors ...RequestEditorFn) (*BetaMessageBatchesResultsResponse, error)

	// BetaMessagesCountTokensPostWithBodyWithResponse request with any body
	BetaMessagesCountTokensPostWithBodyWithResponse(ctx context.Context, params *BetaMessagesCountTokensPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BetaMessagesCountTokensPostResponse, error)

	BetaMessagesCountTokensPostWithResponse(ctx context.Context, params *BetaMessagesCountTokensPostParams, body BetaMessagesCountTokensPostJSONRequestBody, reqEditors ...RequestEditorFn) (*BetaMessagesCountTokensPostResponse, error)

	// PromptCachingBetaMessagesPostWithBodyWithResponse request with any body
	PromptCachingBetaMessagesPostWithBodyWithResponse(ctx context.Context, params *PromptCachingBetaMessagesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromptCachingBetaMessagesPostResponse, error)

	PromptCachingBetaMessagesPostWithResponse(ctx context.Context, params *PromptCachingBetaMessagesPostParams, body PromptCachingBetaMessagesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PromptCachingBetaMessagesPostResponse, error)
}

type CompletePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompletionResponse
	JSON4XX      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CompletePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompletePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MessagesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Message
	JSON4XX      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MessagesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MessagesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaMessageBatchesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaListResponseMessageBatch
	JSON4XX      *BetaErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaMessageBatchesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaMessageBatchesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaMessageBatchesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaMessageBatch
	JSON4XX      *BetaErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaMessageBatchesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaMessageBatchesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaMessageBatchesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaMessageBatch
	JSON4XX      *BetaErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaMessageBatchesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaMessageBatchesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaMessageBatchesCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaMessageBatch
	JSON4XX      *BetaErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaMessageBatchesCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaMessageBatchesCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaMessageBatchesResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *BetaErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaMessageBatchesResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaMessageBatchesResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaMessagesCountTokensPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaCountMessageTokensResponse
	JSON4XX      *BetaErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaMessagesCountTokensPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaMessagesCountTokensPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromptCachingBetaMessagesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PromptCachingBetaMessage
	JSON4XX      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PromptCachingBetaMessagesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromptCachingBetaMessagesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CompletePostWithBodyWithResponse request with arbitrary body returning *CompletePostResponse
func (c *ClientWithResponses) CompletePostWithBodyWithResponse(ctx context.Context, params *CompletePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompletePostResponse, error) {
	rsp, err := c.CompletePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompletePostResponse(rsp)
}

func (c *ClientWithResponses) CompletePostWithResponse(ctx context.Context, params *CompletePostParams, body CompletePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CompletePostResponse, error) {
	rsp, err := c.CompletePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompletePostResponse(rsp)
}

// MessagesPostWithBodyWithResponse request with arbitrary body returning *MessagesPostResponse
func (c *ClientWithResponses) MessagesPostWithBodyWithResponse(ctx context.Context, params *MessagesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MessagesPostResponse, error) {
	rsp, err := c.MessagesPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMessagesPostResponse(rsp)
}

func (c *ClientWithResponses) MessagesPostWithResponse(ctx context.Context, params *MessagesPostParams, body MessagesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MessagesPostResponse, error) {
	rsp, err := c.MessagesPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMessagesPostResponse(rsp)
}

// BetaMessageBatchesListWithResponse request returning *BetaMessageBatchesListResponse
func (c *ClientWithResponses) BetaMessageBatchesListWithResponse(ctx context.Context, params *BetaMessageBatchesListParams, reqEditors ...RequestEditorFn) (*BetaMessageBatchesListResponse, error) {
	rsp, err := c.BetaMessageBatchesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBetaMessageBatchesListResponse(rsp)
}

// BetaMessageBatchesPostWithBodyWithResponse request with arbitrary body returning *BetaMessageBatchesPostResponse
func (c *ClientWithResponses) BetaMessageBatchesPostWithBodyWithResponse(ctx context.Context, params *BetaMessageBatchesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BetaMessageBatchesPostResponse, error) {
	rsp, err := c.BetaMessageBatchesPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBetaMessageBatchesPostResponse(rsp)
}

func (c *ClientWithResponses) BetaMessageBatchesPostWithResponse(ctx context.Context, params *BetaMessageBatchesPostParams, body BetaMessageBatchesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*BetaMessageBatchesPostResponse, error) {
	rsp, err := c.BetaMessageBatchesPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBetaMessageBatchesPostResponse(rsp)
}

// BetaMessageBatchesRetrieveWithResponse request returning *BetaMessageBatchesRetrieveResponse
func (c *ClientWithResponses) BetaMessageBatchesRetrieveWithResponse(ctx context.Context, messageBatchId string, params *BetaMessageBatchesRetrieveParams, reqEditors ...RequestEditorFn) (*BetaMessageBatchesRetrieveResponse, error) {
	rsp, err := c.BetaMessageBatchesRetrieve(ctx, messageBatchId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBetaMessageBatchesRetrieveResponse(rsp)
}

// BetaMessageBatchesCancelWithResponse request returning *BetaMessageBatchesCancelResponse
func (c *ClientWithResponses) BetaMessageBatchesCancelWithResponse(ctx context.Context, messageBatchId string, params *BetaMessageBatchesCancelParams, reqEditors ...RequestEditorFn) (*BetaMessageBatchesCancelResponse, error) {
	rsp, err := c.BetaMessageBatchesCancel(ctx, messageBatchId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBetaMessageBatchesCancelResponse(rsp)
}

// BetaMessageBatchesResultsWithResponse request returning *BetaMessageBatchesResultsResponse
func (c *ClientWithResponses) BetaMessageBatchesResultsWithResponse(ctx context.Context, messageBatchId string, params *BetaMessageBatchesResultsParams, reqEditors ...RequestEditorFn) (*BetaMessageBatchesResultsResponse, error) {
	rsp, err := c.BetaMessageBatchesResults(ctx, messageBatchId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBetaMessageBatchesResultsResponse(rsp)
}

// BetaMessagesCountTokensPostWithBodyWithResponse request with arbitrary body returning *BetaMessagesCountTokensPostResponse
func (c *ClientWithResponses) BetaMessagesCountTokensPostWithBodyWithResponse(ctx context.Context, params *BetaMessagesCountTokensPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BetaMessagesCountTokensPostResponse, error) {
	rsp, err := c.BetaMessagesCountTokensPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBetaMessagesCountTokensPostResponse(rsp)
}

func (c *ClientWithResponses) BetaMessagesCountTokensPostWithResponse(ctx context.Context, params *BetaMessagesCountTokensPostParams, body BetaMessagesCountTokensPostJSONRequestBody, reqEditors ...RequestEditorFn) (*BetaMessagesCountTokensPostResponse, error) {
	rsp, err := c.BetaMessagesCountTokensPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBetaMessagesCountTokensPostResponse(rsp)
}

// PromptCachingBetaMessagesPostWithBodyWithResponse request with arbitrary body returning *PromptCachingBetaMessagesPostResponse
func (c *ClientWithResponses) PromptCachingBetaMessagesPostWithBodyWithResponse(ctx context.Context, params *PromptCachingBetaMessagesPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromptCachingBetaMessagesPostResponse, error) {
	rsp, err := c.PromptCachingBetaMessagesPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptCachingBetaMessagesPostResponse(rsp)
}

func (c *ClientWithResponses) PromptCachingBetaMessagesPostWithResponse(ctx context.Context, params *PromptCachingBetaMessagesPostParams, body PromptCachingBetaMessagesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PromptCachingBetaMessagesPostResponse, error) {
	rsp, err := c.PromptCachingBetaMessagesPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptCachingBetaMessagesPostResponse(rsp)
}

// ParseCompletePostResponse parses an HTTP response from a CompletePostWithResponse call
func ParseCompletePostResponse(rsp *http.Response) (*CompletePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompletePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompletionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	}

	return response, nil
}

// ParseMessagesPostResponse parses an HTTP response from a MessagesPostWithResponse call
func ParseMessagesPostResponse(rsp *http.Response) (*MessagesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MessagesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	}

	return response, nil
}

// ParseBetaMessageBatchesListResponse parses an HTTP response from a BetaMessageBatchesListWithResponse call
func ParseBetaMessageBatchesListResponse(rsp *http.Response) (*BetaMessageBatchesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BetaMessageBatchesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaListResponseMessageBatch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest BetaErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	}

	return response, nil
}

// ParseBetaMessageBatchesPostResponse parses an HTTP response from a BetaMessageBatchesPostWithResponse call
func ParseBetaMessageBatchesPostResponse(rsp *http.Response) (*BetaMessageBatchesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BetaMessageBatchesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaMessageBatch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest BetaErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	}

	return response, nil
}

// ParseBetaMessageBatchesRetrieveResponse parses an HTTP response from a BetaMessageBatchesRetrieveWithResponse call
func ParseBetaMessageBatchesRetrieveResponse(rsp *http.Response) (*BetaMessageBatchesRetrieveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BetaMessageBatchesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaMessageBatch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest BetaErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	}

	return response, nil
}

// ParseBetaMessageBatchesCancelResponse parses an HTTP response from a BetaMessageBatchesCancelWithResponse call
func ParseBetaMessageBatchesCancelResponse(rsp *http.Response) (*BetaMessageBatchesCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BetaMessageBatchesCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaMessageBatch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest BetaErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	}

	return response, nil
}

// ParseBetaMessageBatchesResultsResponse parses an HTTP response from a BetaMessageBatchesResultsWithResponse call
func ParseBetaMessageBatchesResultsResponse(rsp *http.Response) (*BetaMessageBatchesResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BetaMessageBatchesResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest BetaErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	}

	return response, nil
}

// ParseBetaMessagesCountTokensPostResponse parses an HTTP response from a BetaMessagesCountTokensPostWithResponse call
func ParseBetaMessagesCountTokensPostResponse(rsp *http.Response) (*BetaMessagesCountTokensPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BetaMessagesCountTokensPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaCountMessageTokensResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest BetaErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	}

	return response, nil
}

// ParsePromptCachingBetaMessagesPostResponse parses an HTTP response from a PromptCachingBetaMessagesPostWithResponse call
func ParsePromptCachingBetaMessagesPostResponse(rsp *http.Response) (*PromptCachingBetaMessagesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromptCachingBetaMessagesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PromptCachingBetaMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	}

	return response, nil
}
